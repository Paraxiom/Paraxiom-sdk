import { ApiOptions, SubmittableExtrinsic } from '@polkadot/api/types';
import { KeyringPair, KeyringPair$Json } from '@polkadot/keyring/types';
import { MochaOptions } from 'mocha';
import { ApiPromise, WsProvider } from '@polkadot/api';
import { IEvent, ISubmittableResult } from '@polkadot/types/types';
import { IEventRecord } from '@polkadot/types/types/events';
import { ContractPromise } from '@polkadot/api-contract';
import { ChildProcess } from 'child_process';
import { SignerOptions } from '@polkadot/api/submittable/types';

declare global {
    const expect: Chai.ExpectStatic;
}

type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};
interface FixedArray<L extends number, T> extends ArrayLike<T> {
    length: L;
}
type ComponentName = 'node' | 'pruntime' | 'pherry';
declare enum RunMode {
    Simple = "Simple",
    Testing = "Testing"
}
interface StackComponentOptions {
    binary: string;
    workingDir: string;
    args: Record<string, any>;
    envs: NodeJS.ProcessEnv;
    timeout: number;
}
interface NodeComponentOptions extends StackComponentOptions {
    port: number;
}
interface PruntimeComponentOptions extends StackComponentOptions {
    port: number;
}
interface PherryComponentOptions extends StackComponentOptions {
    gkMnemonic: string;
}
type Accounts = {
    alice?: KeyringPair;
    bob?: KeyringPair;
    charlie?: KeyringPair;
    dave?: KeyringPair;
    eve?: KeyringPair;
    ferdie?: KeyringPair;
    [name: string]: KeyringPair;
};
type AccountKey = keyof Accounts | string;
type AccountKeyringsConfig = {
    [name: string]: string | KeyringPair$Json;
};
type AccountsConfig = {
    keyrings: AccountKeyringsConfig;
    suAccount: string;
};
type NetworkConfig = {
    nodeUrl: string;
    nodeApiOptions?: ApiOptions;
    workerUrl: string;
    blockTime: number;
};
type StackSetupOptions = {
    workerUrl?: string;
    clusterId?: string;
};
type StackSetupResult = {
    clusterId: string;
};
type DevPhaseOptions = NetworkConfig & StackSetupOptions;
interface TestingOptions {
    mocha: MochaOptions;
    spawnStack: boolean;
    envSetup: {
        setup: {
            custom: (devPhase: any) => Promise<void>;
            timeout: number;
        };
        teardown: {
            custom: (devPhase: any) => Promise<void>;
            timeout: number;
        };
    };
    blockTime: number;
    stackLogOutput: boolean;
}
type GeneralConfig = {
    ss58Format: number;
};
type ProjectConfig = {
    general: GeneralConfig;
    directories: {
        artifacts: string;
        contracts: string;
        logs: string;
        stacks: string;
        tests: string;
        typings: string;
    };
    stack: {
        blockTime: number;
        version: string;
        setupOptions: StackSetupOptions;
        node: NodeComponentOptions;
        pruntime: PruntimeComponentOptions;
        pherry: PherryComponentOptions;
    };
    testing: TestingOptions;
    networks: {
        [networkName: string]: NetworkConfig;
    };
    accountsConfig: AccountsConfig;
};
type ProjectConfigOptions = RecursivePartial<ProjectConfig>;
type RuntimePaths = {
    devphase: string;
    templates: string;
    project: string;
    context: string;
    artifacts: string;
    contracts: string;
    logs: string;
    currentLog: string;
    scripts: string;
    stacks: string;
    currentStack: string;
    tests: string;
    typings: string;
};
declare enum ContractType {
    InkCode = "InkCode",
    SidevmCode = "SidevmCode"
}

type HandlerCallee = (event: IEvent<any>) => Promise<void>;
type ArgsFilters = {
    [dataKey: number]: any | any[];
};
type HandlerDescription = {
    callee: HandlerCallee;
    argsFilters: ArgsFilters;
    once: boolean;
    drop?: boolean;
};
declare class EventQueue {
    protected _api: ApiPromise;
    protected _eventsSubscription: any;
    protected _handlers: Record<string, HandlerDescription[]>;
    init(api: ApiPromise): Promise<void>;
    destroy(): Promise<void>;
    registerHandler(eventKey: string, argsFilters: ArgsFilters, callee: HandlerCallee, once?: boolean): void;
    protected _handleEvents(events: IEventRecord<any>[]): Promise<void>;
    protected _checkMatchArgs(argsFilters: ArgsFilters, args: any[]): boolean;
}

declare enum LoggerLevel {
    Debug = 0,
    Log = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
    NoLogging = 5
}
declare class Logger {
    serviceName: string;
    static LOGGER_LEVEL: LoggerLevel;
    constructor(serviceName: string);
    log(...args: any[]): void;
    time(label: string): void;
    timeEnd(label: string): void;
    timeLog(label: string): void;
    timeStamp(label: string): void;
    dir(object: any, options?: any): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
}

type WaitForOptions = {
    checkInterval?: number;
    message?: string;
};

type DeployOptions = {
    asAccount?: AccountKey;
};
type InstantiateOptions = {
    salt?: number;
    asAccount?: AccountKey;
    transfer?: number;
    gasLimit?: number;
    storageDepositLimit?: number;
    deposit?: number;
    transferToCluster?: number;
    adjustStake?: number;
};
declare class ContractFactory {
    readonly contractType: string;
    readonly metadata: ContractMetadata.Metadata;
    readonly clusterId: string;
    protected _logger: Logger;
    protected _devPhase: DevPhase;
    protected _eventQueue: EventQueue;
    get api(): ApiPromise;
    protected init(): Promise<void>;
    static create<T extends ContractFactory>(devPhase: DevPhase, contractType: ContractType, metadata: ContractMetadata.Metadata, clusterId: string): Promise<T>;
    /**
     * Deploying contract to network
     */
    deploy(options?: DeployOptions): Promise<void>;
    /**
     * Creating contract instance
     */
    instantiate<T extends Contract>(constructor: string, params?: any[], options?: InstantiateOptions): Promise<T>;
    attach<T extends Contract>(contractId: string): Promise<T>;
    protected _waitFor(callback: () => Promise<any>, timeLimit: number, options?: WaitForOptions): Promise<any>;
}

type Release = {
    name: string;
    tag_name: string;
    assets: Array<{
        name: string;
        browser_download_url: string;
    }>;
};
declare class StackBinaryDownloader {
    protected _context: RuntimeContext;
    protected static readonly RELEASES_URL = "https://api.github.com/repos/Phala-Network/phala-blockchain/releases";
    protected static readonly RELEASES_CACHE_TIME: number;
    protected static readonly EXECUTABLES: string[];
    protected _logger: Logger;
    protected _releases: Release[];
    constructor(_context: RuntimeContext);
    uniformStackVersion(version: string): Promise<string>;
    getReleases(): Promise<Release[]>;
    findRelease(tagName: string): Promise<Release>;
    downloadIfRequired(): Promise<void>;
}

declare class RuntimeContext {
    protected static readonly SINGLETON_KEY = "devphase_Context_VSffVql3bvj9aulZY5DNnRCnrEt1V27a";
    static readonly NETWORK_LOCAL = "local";
    protected _stackBinaryDownloader: StackBinaryDownloader;
    protected _devPhases: Record<string, DevPhase>;
    readonly config: ProjectConfig;
    readonly paths: RuntimePaths;
    static getSingleton(): Promise<RuntimeContext>;
    private constructor();
    isInProjectDirectory(): Promise<boolean>;
    requestProjectDirectory(): Promise<void>;
    initContext(runMode: RunMode, network?: string): Promise<void>;
    initDevPhase(network?: string): Promise<DevPhase>;
    getDevPhase(network?: string): DevPhase;
    requestStackBinaries(): Promise<void>;
    protected _getRunConfiguration(options: ProjectConfigOptions, runMode: RunMode): Promise<ProjectConfig>;
}

type WorkerInfo = {
    publicKey: string;
    ecdhPublicKey: string;
};
type GetFactoryOptions = {
    clusterId?: string;
};
declare class DevPhase {
    readonly api: ApiPromise;
    readonly network: string;
    readonly networkConfig: NetworkConfig;
    readonly workerUrl: string;
    readonly accounts: Accounts;
    readonly suAccount: KeyringPair;
    readonly mainClusterId: string;
    readonly runtimeContext: RuntimeContext;
    protected _logger: Logger;
    protected _apiProvider: WsProvider;
    protected _apiOptions: ApiOptions;
    protected _eventQueue: EventQueue;
    protected _workerInfo: WorkerInfo;
    private constructor();
    static create(runtimeContext: RuntimeContext, network: string): Promise<DevPhase>;
    createApiPromise(): Promise<ApiPromise>;
    stackSetup(): Promise<void>;
    /**
     * Cleanup task
     */
    cleanup(): Promise<void>;
    getFactory<T extends ContractFactory>(type: ContractType, artifactPathOrName: string, options?: GetFactoryOptions): Promise<T>;
}

declare class StackManager {
    protected _context: RuntimeContext;
    protected _logger: Logger;
    protected _processes: Record<ComponentName, ChildProcess>;
    protected _killFlag: boolean;
    protected _runLogsPath: string;
    constructor(_context: RuntimeContext);
    startStack(runMode: RunMode): Promise<Record<ComponentName, ChildProcess>>;
    stopStack(force?: boolean): Promise<void>;
    startNode(runMode: RunMode): Promise<ChildProcess>;
    startPruntime(runMode: RunMode): Promise<ChildProcess>;
    startPherry(runMode: RunMode): Promise<ChildProcess>;
    startComponent(componentName: string, options: StackComponentOptions, runMode: RunMode, waitForReady?: (text: string) => boolean, waitForError?: (text: string) => boolean): Promise<ChildProcess>;
    getComponentPath(_path: string): string;
    isLogOutputUsed(runMode: RunMode, context: RuntimeContext): boolean;
}

declare module 'mocha' {
    interface Context {
        runtimeContext: RuntimeContext;
        devPhase: DevPhase;
        stackManager: StackManager;
        api: ApiPromise;
    }
}

declare class Contract extends ContractPromise {
    readonly clusterId: string;
    readonly contractId: string;
}

declare namespace ContractMetadata {
    type TypeRef = {
        displayName: string[];
        type: number;
    };
    type Argument = {
        label: string;
        type: TypeRef;
        docs: string[];
    };
    type IndexedArgument = Argument & {
        indexed: boolean;
    };
    type Constructor = {
        label: string;
        args: Argument[];
        selector: string;
        payable: boolean;
        docs: string[];
    };
    type Message = {
        label: string;
        args: Argument[];
        selector: string;
        payable: boolean;
        mutates: boolean;
        returnType: TypeRef;
        docs: string[];
    };
    type Spec = {
        constructors: Constructor[];
        events: IndexedArgument[];
        messages: Message[];
        docs: string[];
    };
    type Storage = {
        struct: {
            fields: Array<{
                name: string;
                layout: {
                    cell: {
                        key: string;
                        ty: number;
                    };
                };
            }>;
        };
    };
    namespace Type {
        type Primitive = {
            def: {
                primitive: string;
            };
        };
        type Variant = {
            def: {
                variant: {
                    variants: Array<{
                        fields: Array<TypeRef>;
                        index: number;
                        name: string;
                    }>;
                };
            };
            params: {
                name: string;
                type: number;
            }[];
            path: string[];
        };
        type Composite = {
            def: {
                composite: {
                    fields: Array<{
                        name?: string;
                        type: number;
                        typeName: string;
                    }>;
                };
            };
            path: string[];
        };
        type ArrayType = {
            def: {
                array: {
                    len: string;
                    type: number;
                };
            };
        };
        type Sequence = {
            def: {
                sequence: {
                    type: number;
                };
            };
        };
        type Tuple = {
            def: {
                tuple: Array<number>;
            };
        };
    }
    type TypeDefType = Type.Primitive | Type.Variant | Type.Composite | Type.ArrayType | Type.Sequence | Type.Tuple;
    type TypeDef = {
        id: number;
        type: TypeDefType;
    };
    type ABI = {
        spec: Spec;
        storage: Storage;
        types: TypeDef[];
    };
    type Metadata = {
        source: {
            hash: string;
            language: string;
            compiler: string;
            wasm: string;
        };
        contract: {
            name: string;
            version: string;
            authors: string[];
        };
        V3: ABI;
    };
}

declare class TxHandler {
    static handle(transaction: SubmittableExtrinsic<any>, keyringPair: KeyringPair, transactionId: string, options?: Partial<SignerOptions>): Promise<ISubmittableResult>;
}

export { AccountKey, AccountKeyringsConfig, Accounts, AccountsConfig, ComponentName, Contract, ContractFactory, ContractMetadata, ContractType, DeployOptions, DevPhase, DevPhaseOptions, FixedArray, GeneralConfig, GetFactoryOptions, InstantiateOptions, Logger, LoggerLevel, NetworkConfig, NodeComponentOptions, PherryComponentOptions, ProjectConfig, ProjectConfigOptions, PruntimeComponentOptions, RecursivePartial, RunMode, RuntimeContext, RuntimePaths, StackComponentOptions, StackManager, StackSetupOptions, StackSetupResult, TestingOptions, TxHandler };
