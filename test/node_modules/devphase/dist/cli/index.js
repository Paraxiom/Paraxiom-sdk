#! /usr/bin/env ts-node-script
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/def.ts
var RunMode, ContractType;
var init_def = __esm({
  "src/def.ts"() {
    "use strict";
    (function(RunMode2) {
      RunMode2["Simple"] = "Simple";
      RunMode2["Testing"] = "Testing";
    })(RunMode || (RunMode = {}));
    (function(ContractType2) {
      ContractType2["InkCode"] = "InkCode";
      ContractType2["SidevmCode"] = "SidevmCode";
    })(ContractType || (ContractType = {}));
  }
});

// src/service/api/EventQueue.ts
var EventQueue;
var init_EventQueue = __esm({
  "src/service/api/EventQueue.ts"() {
    "use strict";
    EventQueue = class {
      _handlers = {};
      async init(api) {
        this._api = api;
        this._eventsSubscription = await this._api.query.system.events((events) => this._handleEvents(events));
      }
      async destroy() {
        if (this._eventsSubscription instanceof Function) {
          await this._eventsSubscription();
        }
      }
      registerHandler(eventKey, argsFilters = {}, callee, once = true) {
        if (!this._handlers[eventKey]) {
          this._handlers[eventKey] = [];
        }
        this._handlers[eventKey].push({
          callee,
          argsFilters,
          once
        });
      }
      async _handleEvents(events) {
        var _a;
        for (const { event } of events) {
          const eventKey = event.section + "." + event.method;
          if (!((_a = this._handlers[eventKey]) == null ? void 0 : _a.length)) {
            continue;
          }
          const eventData = event.data.toJSON();
          for (const handler of this._handlers[eventKey]) {
            const matchArgs = this._checkMatchArgs(handler.argsFilters, eventData);
            if (matchArgs) {
              await handler.callee(event);
              if (handler.once) {
                handler.drop = true;
              }
            }
          }
          this._handlers[eventKey] = this._handlers[eventKey].filter((handler) => !handler.drop);
        }
      }
      _checkMatchArgs(argsFilters, args) {
        for (const [argIdx, argFilter] of Object.entries(argsFilters)) {
          const argValue = args[argIdx];
          if (argFilter instanceof Array) {
            if (!argFilter.includes(argValue)) {
              return false;
            }
          } else if (argFilter != argValue) {
            return false;
          }
        }
        return true;
      }
    };
    __name(EventQueue, "EventQueue");
  }
});

// src/utils/Logger.ts
var import_chalk, LoggerLevel, _Logger, Logger;
var init_Logger = __esm({
  "src/utils/Logger.ts"() {
    "use strict";
    import_chalk = __toESM(require("chalk"));
    (function(LoggerLevel2) {
      LoggerLevel2[LoggerLevel2["Debug"] = 0] = "Debug";
      LoggerLevel2[LoggerLevel2["Log"] = 1] = "Log";
      LoggerLevel2[LoggerLevel2["Info"] = 2] = "Info";
      LoggerLevel2[LoggerLevel2["Warn"] = 3] = "Warn";
      LoggerLevel2[LoggerLevel2["Error"] = 4] = "Error";
      LoggerLevel2[LoggerLevel2["NoLogging"] = 5] = "NoLogging";
    })(LoggerLevel || (LoggerLevel = {}));
    _Logger = class {
      constructor(serviceName) {
        this.serviceName = serviceName;
      }
      log(...args) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
          return;
        }
        const logArgs = [
          ...args
        ];
        logArgs.unshift(import_chalk.default.white(`[${this.serviceName}]`));
        console.log(...logArgs);
      }
      time(label) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
          return;
        }
        const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
        console.time(text);
      }
      timeEnd(label) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
          return;
        }
        const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
        console.timeEnd(text);
      }
      timeLog(label) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
          return;
        }
        const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
        console.timeLog(text);
      }
      timeStamp(label) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
          return;
        }
        const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
        console.timeStamp(text);
      }
      dir(object, options) {
        const serviceName = import_chalk.default.white(`[${this.serviceName}]`);
        console.log(serviceName);
        console.dir(object, options);
      }
      debug(...args) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Debug) {
          return;
        }
        const logArgs = [
          ...args
        ];
        logArgs.unshift(import_chalk.default.grey(`[${this.serviceName}]`));
        console.debug(...logArgs);
      }
      info(...args) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Info) {
          return;
        }
        const logArgs = [
          ...args
        ];
        logArgs.unshift(import_chalk.default.cyan(`[${this.serviceName}]`));
        console.info(...logArgs);
      }
      warn(...args) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Warn) {
          return;
        }
        const logArgs = [
          ...args
        ];
        logArgs.unshift(import_chalk.default.yellow(`[${this.serviceName}]`));
        console.warn(...logArgs);
      }
      error(...args) {
        if (_Logger.LOGGER_LEVEL > LoggerLevel.Error) {
          return;
        }
        const logArgs = [
          ...args
        ];
        logArgs.unshift(import_chalk.default.red(`[${this.serviceName}]`));
        console.error(...logArgs);
      }
    };
    Logger = _Logger;
    __name(Logger, "Logger");
    __publicField(Logger, "LOGGER_LEVEL", LoggerLevel.Log);
  }
});

// src/service/api/TxHandler.ts
var import_chalk2, logger, TxHandler;
var init_TxHandler = __esm({
  "src/service/api/TxHandler.ts"() {
    "use strict";
    init_Logger();
    import_chalk2 = __toESM(require("chalk"));
    logger = new Logger("TxHandler");
    TxHandler = class {
      static async handle(transaction, keyringPair, transactionId, options) {
        return new Promise(async (resolve, reject) => {
          const unsub = await transaction.signAndSend(keyringPair, options, (result, extra) => {
            if (result.status.isReady) {
              logger.debug(transactionId + ": " + import_chalk2.default.grey("ready"));
            } else if (result.status.isBroadcast) {
              logger.debug(transactionId + ": " + import_chalk2.default.grey("brodcast"));
            } else if (result.status.isInvalid) {
              logger.debug(transactionId + ": " + import_chalk2.default.red("invalid"));
              reject(result);
            } else if (result.status.isDropped) {
              logger.debug(transactionId + ": " + import_chalk2.default.red("dropped"));
              reject(result);
            } else if (result.status.isRetracted) {
              logger.debug(transactionId + ": " + import_chalk2.default.red("retracted"));
              reject(result);
            } else if (result.status.isInBlock) {
              logger.debug(transactionId + ": " + import_chalk2.default.green("in block"));
              resolve(result);
            } else if (result.status.isUsurped) {
              logger.debug(transactionId + ": " + import_chalk2.default.green("is usurped"));
              reject(result);
            }
            if (result.status.isFinalized || result.status.isFinalityTimeout) {
              resolve(result);
              unsub();
            }
          });
        });
      }
    };
    __name(TxHandler, "TxHandler");
  }
});

// src/utils/Exception.ts
var Exception;
var init_Exception = __esm({
  "src/utils/Exception.ts"() {
    "use strict";
    Exception = class extends Error {
      name = "Throwable";
      constructor(message, code = -1, error) {
        super(message);
        this.code = code;
        if (error) {
          this._initErrorMessage(this.message, error);
        }
      }
      toString() {
        return this.name + ": " + this.message;
      }
      _initErrorMessage(message, error) {
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error(message).stack;
        }
        const messageLines = (this.message.match(/\n/g) || []).length + 1;
        this.stack = this.constructor.name + ": [" + this.code + "] " + message + "\n" + this.stack.split("\n").slice(1, messageLines + 1).join("\n") + "\n" + error.stack;
      }
    };
    __name(Exception, "Exception");
  }
});

// src/utils/waitFor.ts
async function waitFor(callback, timeLimit, options = {}) {
  options = {
    checkInterval: 500,
    message: "Timeout",
    ...options
  };
  let _intervalHandle = null;
  let _timeoutHandle = null;
  return new Promise((resolve, reject) => {
    _intervalHandle = setInterval(async () => {
      try {
        const result = await callback();
        if (result) {
          clearTimeout(_timeoutHandle);
          clearInterval(_intervalHandle);
          resolve(result);
        }
      } catch (e) {
        clearTimeout(_timeoutHandle);
        reject(e);
      }
    }, options.checkInterval);
    _timeoutHandle = setTimeout(() => {
      clearInterval(_intervalHandle);
      reject(new Exception(options.message, 1663946414394));
    }, timeLimit);
  });
}
var init_waitFor = __esm({
  "src/utils/waitFor.ts"() {
    "use strict";
    init_Exception();
    __name(waitFor, "waitFor");
  }
});

// src/service/api/ContractFactory.ts
var PhalaSdk, import_api_contract, import_chalk3, ContractFactory;
var init_ContractFactory = __esm({
  "src/service/api/ContractFactory.ts"() {
    "use strict";
    init_EventQueue();
    init_TxHandler();
    init_Exception();
    init_Logger();
    init_waitFor();
    PhalaSdk = __toESM(require("@phala/sdk"));
    import_api_contract = require("@polkadot/api-contract");
    import_chalk3 = __toESM(require("chalk"));
    ContractFactory = class {
      _logger = new Logger(ContractFactory.name);
      _eventQueue = new EventQueue();
      get api() {
        return this._devPhase.api;
      }
      async init() {
        await this._eventQueue.init(this._devPhase.api);
      }
      static async create(devPhase, contractType, metadata, clusterId) {
        const instance = new ContractFactory();
        instance._devPhase = devPhase;
        if (!clusterId) {
          clusterId = devPhase.mainClusterId;
        }
        Object.assign(instance, {
          contractType,
          metadata,
          clusterId
        });
        await instance.init();
        return instance;
      }
      async deploy(options = {}) {
        options = {
          asAccount: "alice",
          ...options
        };
        await TxHandler.handle(this.api.tx.phalaFatContracts.clusterUploadResource(this.clusterId, this.contractType, this.metadata.source.wasm), this._devPhase.accounts[options.asAccount], "phalaFatContracts.clusterUploadResource");
      }
      async instantiate(constructor, params = [], options = {}) {
        options = {
          salt: 1e9 + Math.round(Math.random() * 8999999999),
          asAccount: "alice",
          transfer: 0,
          gasLimit: 1e12,
          storageDepositLimit: null,
          deposit: 0,
          transferToCluster: 1e12,
          adjustStake: 1e12,
          ...options
        };
        const abi = new import_api_contract.Abi(this.metadata);
        const callData = abi.findConstructor(constructor).toU8a(params);
        const result = await TxHandler.handle(this.api.tx.phalaFatContracts.instantiateContract({
          WasmCode: this.metadata.source.hash
        }, callData, "0x" + options.salt.toString(16), this.clusterId, options.transfer, options.gasLimit, options.storageDepositLimit, options.deposit), this._devPhase.accounts[options.asAccount], "phalaFatContracts.instantiateContract");
        const instantiateEvent = result.events.find(({ event }) => {
          return event.section === "phalaFatContracts" && event.method === "Instantiating";
        });
        if (!instantiateEvent) {
          throw "Error while instantiating contract";
        }
        const contractId = instantiateEvent.event.data[0].toString();
        let instantiated = false;
        let publicKey = null;
        this._eventQueue.registerHandler("phalaFatContracts.Instantiated", {
          0: contractId
        }, async (event) => {
          instantiated = true;
        });
        this._eventQueue.registerHandler("phalaFatContracts.ContractPubkeyAvailable", {
          0: contractId
        }, async (event) => {
          const eventData = event.data.toJSON();
          publicKey = eventData[2];
        });
        try {
          await this._waitFor(async () => {
            return instantiated && !!publicKey;
          }, 2e4, {
            message: "Contract instantiation"
          });
        } catch (e) {
          throw new Exception("Could not get contract public key", 1663952347291, e);
        }
        if (options.transferToCluster) {
          const result1 = await TxHandler.handle(this.api.tx.phalaFatContracts.transferToCluster(options.transferToCluster, this.clusterId, contractId), this._devPhase.accounts[options.asAccount], "phalaFatContracts.transferToCluster");
        }
        if (options.adjustStake) {
          const result2 = await TxHandler.handle(this.api.tx.phalaFatTokenomic.adjustStake(contractId, options.adjustStake), this._devPhase.accounts[options.asAccount], "phalaFatTokenomic.adjustStake");
        }
        return this.attach(contractId);
      }
      async attach(contractId) {
        const api = await this._devPhase.createApiPromise();
        const { api: workerApi } = await PhalaSdk.create({
          api,
          baseURL: this._devPhase.workerUrl,
          contractId,
          autoDeposit: true
        });
        const instance = new import_api_contract.ContractPromise(workerApi, this.metadata, contractId);
        Object.assign(instance, {
          contractId,
          clusterId: this.clusterId
        });
        return instance;
      }
      async _waitFor(callback, timeLimit, options = {}) {
        const firstTry = await callback();
        if (firstTry) {
          return firstTry;
        }
        if (options.message) {
          this._logger.debug("Waiting for", import_chalk3.default.cyan(options.message));
        }
        const result = waitFor(callback, timeLimit, options);
        this._logger.debug(import_chalk3.default.green("Ready"));
        return result;
      }
    };
    __name(ContractFactory, "ContractFactory");
  }
});

// src/service/api/StackSetupService.ts
var import_axios, import_chalk4, import_fs, import_path, _StackSetupService, StackSetupService;
var init_StackSetupService = __esm({
  "src/service/api/StackSetupService.ts"() {
    "use strict";
    init_EventQueue();
    init_TxHandler();
    init_Exception();
    init_Logger();
    init_waitFor();
    import_axios = __toESM(require("axios"));
    import_chalk4 = __toESM(require("chalk"));
    import_fs = __toESM(require("fs"));
    import_path = __toESM(require("path"));
    _StackSetupService = class {
      constructor(_devPhase) {
        this._devPhase = _devPhase;
        this._logger = new Logger(_StackSetupService.name);
        this._accounts = {};
        this._eventQueue = new EventQueue();
        this._context = this._devPhase.runtimeContext;
        this._accounts = this._devPhase.accounts;
        this._suAccount = this._devPhase.suAccount;
        this._blockTime = this._devPhase.runtimeContext.config.stack.blockTime;
        this._waitTime = Math.max(2e4, 4 * this._blockTime);
      }
      async setupStack(options) {
        this._api = this._devPhase.api;
        const setupStackVersion = _StackSetupService.MAP_STACK_TO_SETUP[this._context.config.stack.version] ?? "default";
        const setupStackMethod = "setupStack_" + setupStackVersion;
        if (!this[setupStackMethod]) {
          throw new Exception("Undefined setup environment procedure for this stack version", 1668661427343);
        }
        return this[setupStackMethod](options);
      }
      async setupStack_default(options) {
        await this.prepareWorker(options.workerUrl);
        await this.prepareGatekeeper();
        await this.preparePhatContractsSystem();
        if (options.clusterId === void 0) {
          const clustersNum = (await this._api.query.phalaFatContracts.clusterCounter()).toJSON();
          if (clustersNum == 0) {
            options.clusterId = null;
          } else {
            options.clusterId = "0x0000000000000000000000000000000000000000000000000000000000000000";
          }
        }
        const clusterId = options.clusterId === null ? await this.createCluster() : options.clusterId;
        await this.waitForClusterReady(options.clusterId);
        return {
          clusterId
        };
      }
      async prepareWorker(workerUrl) {
        const workerApi = import_axios.default.create({
          baseURL: workerUrl
        });
        this._workerInfo = await this._waitFor(async () => {
          const { status, data } = await workerApi.get("/get_info", {
            validateStatus: () => true
          });
          if (status === 200) {
            const payload = JSON.parse(data.payload);
            if (!payload.initialized) {
              return false;
            }
            return {
              publicKey: "0x" + payload.public_key,
              ecdhPublicKey: "0x" + payload.ecdh_public_key
            };
          }
          throw new Exception("Unable to get worker info", 1663941402827);
        }, this._waitTime, {
          message: "pRuntime initialization"
        });
        const workerInfo = (await this._api.query.phalaRegistry.workers(this._workerInfo.ecdhPublicKey)).toJSON();
        if (!workerInfo) {
          const tx = this._api.tx.sudo.sudo(this._api.tx.phalaRegistry.forceRegisterWorker(this._workerInfo.publicKey, this._workerInfo.ecdhPublicKey, null));
          const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaRegistry.forceRegisterWorker)");
          await this._waitFor(async () => {
            return (await this._api.query.phalaRegistry.workers(this._workerInfo.ecdhPublicKey)).toJSON();
          }, this._waitTime, {
            message: "Worker registration"
          });
        }
      }
      async prepareGatekeeper() {
        const gatekeepers = (await this._api.query.phalaRegistry.gatekeeper()).toJSON();
        if (!gatekeepers.includes(this._workerInfo.publicKey)) {
          const tx = this._api.tx.sudo.sudo(this._api.tx.phalaRegistry.registerGatekeeper(this._workerInfo.publicKey));
          const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaRegistry.registerGatekeeper)");
        }
        try {
          await this._waitFor(async () => {
            return !(await this._api.query.phalaRegistry.gatekeeperMasterPubkey()).isEmpty;
          }, this._waitTime, {
            message: "GK master key generation"
          });
        } catch (e) {
          throw new Exception("Could not fetch GK master key", 1663941402827);
        }
      }
      async preparePhatContractsSystem() {
        if (!this._context) {
          throw new Exception("Non available out of runtime context environment", 1668658002543);
        }
        const systemContractPath = import_path.default.join(this._context.paths.currentStack, "system.contract");
        if (!import_fs.default.existsSync(systemContractPath)) {
          throw new Exception("Phat contracts system not found in stacks", 1668748436052);
        }
        const systemContract = JSON.parse(import_fs.default.readFileSync(systemContractPath, {
          encoding: "utf-8"
        }));
        const systemCode = systemContract.source.wasm;
        const pinkSystemCode = await this._api.query.phalaFatContracts.pinkSystemCode();
        const isPinkSystemCodeReady = pinkSystemCode[1].toString() === systemCode;
        if (isPinkSystemCodeReady) {
          return;
        }
        this._logger.log("Preparing Phat Contracts system");
        const tx = this._api.tx.sudo.sudo(this._api.tx.phalaFatContracts.setPinkSystemCode(systemCode));
        const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaFatContracts.setPinkSystemCode)");
        await this._waitFor(async () => {
          const code = await this._api.query.phalaFatContracts.pinkSystemCode();
          return code[1].toString() === systemCode;
        }, this._waitTime, {
          message: "PinkSystemCode setup"
        });
      }
      async createCluster() {
        this._logger.log("Creating cluster");
        const tx = this._api.tx.sudo.sudo(this._api.tx.phalaFatContracts.addCluster(
          this._accounts.alice.address,
          {
            Public: null
          },
          [
            this._workerInfo.publicKey
          ],
          1e12,
          1,
          1,
          1,
          this._accounts.alice.address
        ));
        const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaFatContracts.addCluster)");
        const clusterCreatedEvent = result.events.find(({ event }) => {
          return event.section === "phalaFatContracts" && event.method === "ClusterCreated";
        });
        if (!clusterCreatedEvent) {
          throw new Exception("Error while creating cluster", 1663941940784);
        }
        const clusterId = clusterCreatedEvent.event.data[0].toString();
        this._logger.log(import_chalk4.default.green("Cluster created"));
        this._logger.log(clusterId);
        return clusterId;
      }
      async waitForClusterReady(clusterId) {
        return this._waitFor(async () => {
          const cluster = await this._api.query.phalaFatContracts.clusters(clusterId);
          if (cluster.isEmpty) {
            return false;
          }
          const clusterKey = await this._api.query.phalaRegistry.clusterKeys(clusterId);
          if (clusterKey.isEmpty) {
            return false;
          }
          return true;
        }, this._waitTime, {
          message: "Cluster ready"
        });
      }
      async _waitFor(callback, timeLimit, options = {}) {
        const firstTry = await callback();
        if (firstTry) {
          return firstTry;
        }
        if (options.message) {
          this._logger.debug("Waiting for", import_chalk4.default.cyan(options.message));
        }
        const result = waitFor(callback, timeLimit, options);
        this._logger.debug(import_chalk4.default.green("Ready"));
        return result;
      }
    };
    StackSetupService = _StackSetupService;
    __name(StackSetupService, "StackSetupService");
    __publicField(StackSetupService, "MAP_STACK_TO_SETUP", {});
  }
});

// src/service/project/AccountManager.ts
var Keyring, import_util_crypto, import_wasm_crypto, import_chalk5, import_fs2, import_path2, import_prompts, AccountManager;
var init_AccountManager = __esm({
  "src/service/project/AccountManager.ts"() {
    "use strict";
    init_Exception();
    init_Logger();
    Keyring = __toESM(require("@polkadot/keyring"));
    import_util_crypto = require("@polkadot/util-crypto");
    import_wasm_crypto = require("@polkadot/wasm-crypto");
    import_chalk5 = __toESM(require("chalk"));
    import_fs2 = __toESM(require("fs"));
    import_path2 = __toESM(require("path"));
    import_prompts = __toESM(require("prompts"));
    AccountManager = class {
      constructor(_runtimeContext) {
        this._runtimeContext = _runtimeContext;
        this._logger = new Logger(AccountManager.name);
      }
      async loadAccountsKeyringsFromStorageFile() {
        const accountsStoragePath = import_path2.default.join(this._runtimeContext.paths.project, "accounts.json");
        if (!import_fs2.default.existsSync(accountsStoragePath)) {
          return null;
        }
        return JSON.parse(import_fs2.default.readFileSync(accountsStoragePath, {
          encoding: "utf-8"
        }));
      }
      async loadAccounts(accountKeyrings, ss58Format = 30, unlock = true) {
        await (0, import_wasm_crypto.waitReady)();
        const accounts = {};
        const keyring = new Keyring.Keyring();
        if (ss58Format) {
          keyring.setSS58Format(ss58Format);
        }
        for (const [alias, accountKeyring] of Object.entries(accountKeyrings)) {
          if (typeof accountKeyring === "string") {
            accounts[alias] = keyring.createFromUri(accountKeyring, void 0, "sr25519");
          } else {
            accounts[alias] = keyring.createFromJson(accountKeyring);
          }
        }
        if (unlock) {
          for (const [alias1, keyring1] of Object.entries(accounts)) {
            if (keyring1.isLocked) {
              const { password } = await (0, import_prompts.default)({
                type: "password",
                name: "password",
                message: `Account ${import_chalk5.default.cyan(alias1)} is locked. Provide password:`
              });
              try {
                keyring1.unlock(password);
              } catch (e) {
                throw new Exception("Unable to unlock account keyring", 1673268293515, e);
              }
            }
          }
        }
        return accounts;
      }
      async createAccount(ss58Format = 30) {
        const account = {
          alias: "",
          keyring: null
        };
        const { alias } = await (0, import_prompts.default)({
          type: "text",
          name: "alias",
          message: `Account alias`,
          validate: (alias2) => /^[a-z0-9_]+$/.test(alias2)
        });
        account.alias = alias;
        const keyring = new Keyring.Keyring({
          type: "sr25519",
          ss58Format
        });
        const mnemonic = (0, import_util_crypto.mnemonicGenerate)();
        account.keyring = keyring.addFromMnemonic(mnemonic);
        const { password } = await (0, import_prompts.default)({
          type: "password",
          name: "password",
          message: `Account password (leave empty if to save as plain text)`
        });
        const exported = !!password ? account.keyring.toJson(password) : mnemonic;
        const accountsConfigPath = import_path2.default.join(this._runtimeContext.paths.project, "accounts.json");
        if (!import_fs2.default.existsSync(accountsConfigPath)) {
          return null;
        }
        const accountsJson = JSON.parse(import_fs2.default.readFileSync(accountsConfigPath, {
          encoding: "utf-8"
        }));
        accountsJson[alias] = exported;
        import_fs2.default.writeFileSync(accountsConfigPath, JSON.stringify(accountsJson, void 0, 4), {
          encoding: "utf-8"
        });
        return account;
      }
    };
    __name(AccountManager, "AccountManager");
  }
});

// src/utils/replaceRecursive.ts
function replaceRecursive(target, ...source) {
  return (0, import_mergeWith.default)(target, ...source, (obj, src) => {
    if (src instanceof Array) {
      return src;
    }
  });
}
var import_mergeWith;
var init_replaceRecursive = __esm({
  "src/utils/replaceRecursive.ts"() {
    "use strict";
    import_mergeWith = __toESM(require("lodash/mergeWith"));
    __name(replaceRecursive, "replaceRecursive");
  }
});

// src/service/api/DevPhase.ts
var import_api, import_fs3, import_path3, DevPhase;
var init_DevPhase = __esm({
  "src/service/api/DevPhase.ts"() {
    "use strict";
    init_ContractFactory();
    init_EventQueue();
    init_StackSetupService();
    init_AccountManager();
    init_Exception();
    init_Logger();
    init_replaceRecursive();
    import_api = require("@polkadot/api");
    import_fs3 = __toESM(require("fs"));
    import_path3 = __toESM(require("path"));
    DevPhase = class {
      accounts = {};
      mainClusterId = "0x0000000000000000000000000000000000000000000000000000000000000000";
      _logger = new Logger(DevPhase.name);
      _eventQueue = new EventQueue();
      constructor() {
      }
      static async create(runtimeContext, network) {
        const instance = new DevPhase();
        const networkConfig = runtimeContext.config.networks[network];
        if (!networkConfig) {
          throw new Exception("Undefined network", 1673537590278);
        }
        instance._apiOptions = networkConfig.nodeApiOptions;
        instance._apiProvider = new import_api.WsProvider(networkConfig.nodeUrl);
        const api = await instance.createApiPromise();
        await instance._eventQueue.init(api);
        Object.assign(instance, {
          network,
          networkConfig,
          runtimeContext,
          api,
          workerUrl: networkConfig.workerUrl
        });
        const accountManager = new AccountManager(runtimeContext);
        const accountsConfig = replaceRecursive({}, runtimeContext.config.accountsConfig);
        const accountsKeyrings = await accountManager.loadAccountsKeyringsFromStorageFile();
        if (accountsKeyrings) {
          replaceRecursive(accountsConfig, accountsKeyrings);
        }
        const accounts = await accountManager.loadAccounts(accountsConfig.keyrings, runtimeContext.config.general.ss58Format, true);
        Object.assign(instance, {
          accounts,
          suAccount: accounts[accountsConfig.suAccount]
        });
        return instance;
      }
      async createApiPromise() {
        return import_api.ApiPromise.create({
          provider: this._apiProvider,
          ...this._apiOptions
        });
      }
      async stackSetup() {
        if (!this.runtimeContext) {
          throw new Exception("Stack setup is not possible out of runtime context", 1668741635272);
        }
        const stackSetupService = new StackSetupService(this);
        const result = await stackSetupService.setupStack(this.runtimeContext.config.stack.setupOptions);
        Object.assign(this, {
          mainClusterId: result.clusterId
        });
      }
      async cleanup() {
        await this._eventQueue.destroy();
        await this.api.disconnect();
      }
      async getFactory(type, artifactPathOrName, options = {}) {
        options = {
          clusterId: this.mainClusterId,
          ...options
        };
        const isContractName = /^[a-z0-9_]+$/i.test(artifactPathOrName);
        let artifactPath = artifactPathOrName;
        if (isContractName) {
          artifactPath = import_path3.default.join(this.runtimeContext.paths.artifacts, artifactPathOrName, `${artifactPathOrName}.contract`);
        }
        if (!import_fs3.default.existsSync(artifactPath)) {
          throw new Exception("Contract artifact file not found", 1665238985042);
        }
        const contractRaw = import_fs3.default.readFileSync(artifactPath, {
          encoding: "utf-8"
        });
        try {
          const metadata = JSON.parse(contractRaw);
          return ContractFactory.create(this, type, metadata, options.clusterId);
        } catch (e) {
          throw new Exception("Failed to parse contract artifiact JSON", 1665238941553, e);
        }
      }
    };
    __name(DevPhase, "DevPhase");
  }
});

// src/service/project/StackBinaryDownloader.ts
var import_axios2, import_chalk6, import_fs4, import_path4, _StackBinaryDownloader, StackBinaryDownloader;
var init_StackBinaryDownloader = __esm({
  "src/service/project/StackBinaryDownloader.ts"() {
    "use strict";
    init_Exception();
    init_Logger();
    import_axios2 = __toESM(require("axios"));
    import_chalk6 = __toESM(require("chalk"));
    import_fs4 = __toESM(require("fs"));
    import_path4 = __toESM(require("path"));
    _StackBinaryDownloader = class {
      constructor(_context) {
        this._context = _context;
        this._logger = new Logger(_StackBinaryDownloader.name);
      }
      async uniformStackVersion(version) {
        if (version === "latest") {
          const releases = await this.getReleases();
          return releases[0].tag_name;
        }
        return version;
      }
      async getReleases() {
        const cachePath = import_path4.default.join(this._context.paths.context, "releases.json");
        if (import_fs4.default.existsSync(cachePath)) {
          const stat = import_fs4.default.statSync(cachePath);
          const outdated = Date.now() - stat.ctimeMs > _StackBinaryDownloader.RELEASES_CACHE_TIME;
          if (!outdated) {
            const releasesCacheRaw = import_fs4.default.readFileSync(cachePath, {
              encoding: "utf-8"
            });
            this._releases = JSON.parse(releasesCacheRaw);
          }
        }
        if (this._releases) {
          return this._releases;
        }
        const { status, data } = await import_axios2.default.get(_StackBinaryDownloader.RELEASES_URL, {
          validateStatus: () => true
        });
        if (status !== 200) {
          throw new Exception("Unable to fetch releases list", 1668571559267);
        }
        const releasesCacheRaw1 = JSON.stringify(data);
        import_fs4.default.writeFileSync(cachePath, releasesCacheRaw1, {
          encoding: "utf-8"
        });
        return data;
      }
      async findRelease(tagName) {
        const releases = await this.getReleases();
        const targetRelease = releases.find((release) => release.tag_name === tagName);
        if (!targetRelease) {
          throw new Exception(`Unable to find target ${tagName} release`, 1668572613089);
        }
        return targetRelease;
      }
      async downloadIfRequired() {
        const releaseStackPath = this._context.paths.currentStack;
        if (!import_fs4.default.existsSync(releaseStackPath)) {
          this._logger.log("Creating stack directory");
          import_fs4.default.mkdirSync(releaseStackPath, {
            recursive: true
          });
        }
        let needsDownload = !import_fs4.default.existsSync(this._context.config.stack.node.binary);
        if (!needsDownload) {
          return;
        }
        const release = await this.findRelease(this._context.config.stack.version);
        this._logger.log("Downloading stack binaries", import_chalk6.default.cyan(release.name));
        for (const asset of release.assets) {
          const isBinary = _StackBinaryDownloader.EXECUTABLES.includes(asset.name);
          const filePath = import_path4.default.join(releaseStackPath, asset.name);
          if (import_fs4.default.existsSync(filePath)) {
            continue;
          }
          this._logger.log(isBinary ? import_chalk6.default.greenBright(asset.name) : import_chalk6.default.blueBright(asset.name));
          const { status, data } = await import_axios2.default.get(asset.browser_download_url, {
            responseType: "arraybuffer",
            headers: {
              "Content-Type": "application/gzip"
            },
            validateStatus: () => true
          });
          if (status !== 200) {
            throw new Exception("Unable to download release", 1668572702020);
          }
          import_fs4.default.writeFileSync(filePath, data, {
            encoding: "binary"
          });
          if (isBinary) {
            import_fs4.default.chmodSync(filePath, 493);
          }
        }
      }
    };
    StackBinaryDownloader = _StackBinaryDownloader;
    __name(StackBinaryDownloader, "StackBinaryDownloader");
    __publicField(StackBinaryDownloader, "RELEASES_URL", "https://api.github.com/repos/Phala-Network/phala-blockchain/releases");
    __publicField(StackBinaryDownloader, "RELEASES_CACHE_TIME", 60 * 60 * 1e3);
    __publicField(StackBinaryDownloader, "EXECUTABLES", [
      "phala-node",
      "pruntime",
      "pherry"
    ]);
  }
});

// src/utils/accessThroughPath.ts
function accessThroughPath(obj, path14, options = {}) {
  options = {
    throwOnFailure: true,
    autoCreate: false,
    ...options
  };
  const parts = path14.split(".");
  const currentPath = [];
  let part = null;
  while (part = parts.shift()) {
    currentPath.push(part);
    const isLeaf = !parts.length;
    if (obj[part] === void 0) {
      if (isLeaf) {
        return void 0;
      } else if (options.autoCreate) {
        obj[part] = {};
      } else if (options.throwOnFailure) {
        const fullPath = currentPath.join(".");
        throw new Exception(`Undefined node at ${fullPath}`, 1641922707436);
      } else {
        return void 0;
      }
    }
    obj = obj[part];
  }
  return obj;
}
var init_accessThroughPath = __esm({
  "src/utils/accessThroughPath.ts"() {
    "use strict";
    init_Exception();
    __name(accessThroughPath, "accessThroughPath");
  }
});

// src/utils/replacePlaceholders.ts
function replacePlaceholders(node, root, options = {}) {
  options = {
    placeholderRegex: /\{\{(.*?)\}\}/g,
    ...options
  };
  for (const [prop, value] of Object.entries(node)) {
    if (typeof value === "string") {
      node[prop] = value.replaceAll(options.placeholderRegex, (match, path14) => {
        return accessThroughPath(root, path14);
      });
    } else if (value instanceof Object) {
      replacePlaceholders(value, root, options);
    }
  }
}
var init_replacePlaceholders = __esm({
  "src/utils/replacePlaceholders.ts"() {
    "use strict";
    init_accessThroughPath();
    __name(replacePlaceholders, "replacePlaceholders");
  }
});

// src/service/project/RuntimeContext.ts
var import_sdk, import_typedefs, import_find_up, import_fs5, import_path5, _RuntimeContext, RuntimeContext;
var init_RuntimeContext = __esm({
  "src/service/project/RuntimeContext.ts"() {
    "use strict";
    init_def();
    init_DevPhase();
    init_StackBinaryDownloader();
    init_Exception();
    init_replacePlaceholders();
    init_replaceRecursive();
    import_sdk = require("@phala/sdk");
    import_typedefs = require("@phala/typedefs");
    import_find_up = __toESM(require("find-up"));
    import_fs5 = __toESM(require("fs"));
    import_path5 = __toESM(require("path"));
    _RuntimeContext = class {
      _devPhases = {};
      paths = {
        devphase: null,
        templates: null,
        project: null,
        context: null,
        artifacts: null,
        contracts: null,
        logs: null,
        currentLog: null,
        scripts: null,
        stacks: null,
        currentStack: null,
        tests: null,
        typings: null
      };
      static async getSingleton() {
        const globalAny = global;
        const singletonKey = _RuntimeContext.SINGLETON_KEY;
        if (!globalAny[singletonKey]) {
          const instance = new _RuntimeContext();
          globalAny[singletonKey] = instance;
        }
        return globalAny[singletonKey];
      }
      constructor() {
        this._stackBinaryDownloader = new StackBinaryDownloader(this);
      }
      async isInProjectDirectory() {
        const configFilePath = await (0, import_find_up.default)([
          "devphase.config.ts",
          "devphase.config.js"
        ]);
        return configFilePath !== void 0;
      }
      async requestProjectDirectory() {
        const isInProjectDirectory = await this.isInProjectDirectory();
        if (!isInProjectDirectory) {
          throw new Exception("Config file not found", 1665952724703);
        }
      }
      async initContext(runMode, network = _RuntimeContext.NETWORK_LOCAL) {
        const configFilePath = await (0, import_find_up.default)([
          "devphase.config.ts",
          "devphase.config.js"
        ]);
        this.paths.devphase = __dirname.endsWith("/cli") ? import_path5.default.join(__dirname, "../../") : import_path5.default.join(__dirname, "../");
        this.paths.templates = import_path5.default.join(this.paths.devphase, "templates");
        let userConfig = {};
        if (configFilePath) {
          this.paths.project = import_path5.default.dirname(configFilePath);
          userConfig = require(configFilePath).default;
        } else {
          this.paths.project = process.cwd();
        }
        this.paths.context = import_path5.default.join(this.paths.project, ".devphase");
        if (!import_fs5.default.existsSync(this.paths.context)) {
          import_fs5.default.mkdirSync(this.paths.context, {
            recursive: true
          });
        }
        const config = await this._getRunConfiguration(userConfig, runMode);
        Object.assign(this, {
          config
        });
        for (const [name, directory] of Object.entries(this.config.directories)) {
          this.paths[name] = import_path5.default.resolve(this.paths.project, directory);
        }
        const logStamp = new Date().toISOString();
        this.paths.currentLog = import_path5.default.join(this.paths.logs, logStamp);
        this.paths.currentStack = import_path5.default.join(this.paths.stacks, this.config.stack.version);
        if (runMode === RunMode.Testing) {
          this.config.networks.local.blockTime = this.config.testing.blockTime;
        }
      }
      async initDevPhase(network = _RuntimeContext.NETWORK_LOCAL) {
        if (this._devPhases[network]) {
          throw new Exception("DevPhase was already initiated", 1673451278525);
        }
        this._devPhases[network] = await DevPhase.create(this, network);
        return this._devPhases[network];
      }
      getDevPhase(network = _RuntimeContext.NETWORK_LOCAL) {
        if (!this._devPhases[network]) {
          throw new Exception("DevPhase is not ready yet", 1673451408519);
        }
        return this._devPhases[network];
      }
      async requestStackBinaries() {
        await this._stackBinaryDownloader.downloadIfRequired();
      }
      async _getRunConfiguration(options, runMode) {
        const config = replaceRecursive({
          general: {
            ss58Format: 30
          },
          directories: {
            artifacts: "artifacts",
            contracts: "contracts",
            logs: "logs",
            stacks: "stacks",
            tests: "tests",
            typings: "typings"
          },
          stack: {
            blockTime: 6e3,
            version: "latest",
            setupOptions: {
              workerUrl: "http://localhost:{{stack.pruntime.port}}",
              clusterId: void 0
            },
            node: {
              port: 9944,
              binary: "{{directories.stacks}}/{{stack.version}}/phala-node",
              workingDir: "{{directories.stacks}}/.data/node",
              envs: {},
              args: {
                "--dev": true,
                "--rpc-methods": "Unsafe",
                "--block-millisecs": "{{stack.blockTime}}",
                "--ws-port": "{{stack.node.port}}",
                "--base-path": "."
              },
              timeout: 1e4
            },
            pruntime: {
              port: 8e3,
              binary: "{{directories.stacks}}/{{stack.version}}/pruntime",
              workingDir: "{{directories.stacks}}/.data/pruntime",
              envs: {},
              args: {
                "--allow-cors": true,
                "--cores": 0,
                "--port": "{{stack.pruntime.port}}"
              },
              timeout: 2e3
            },
            pherry: {
              gkMnemonic: "//Alice",
              binary: "{{directories.stacks}}/{{stack.version}}/pherry",
              workingDir: "{{directories.stacks}}/.data/pherry",
              envs: {},
              args: {
                "--no-wait": true,
                "--mnemonic": "{{stack.pherry.gkMnemonic}}",
                "--inject-key": "0000000000000000000000000000000000000000000000000000000000000001",
                "--substrate-ws-endpoint": "ws://localhost:{{stack.node.port}}",
                "--pruntime-endpoint": "http://localhost:{{stack.pruntime.port}}",
                "--dev-wait-block-ms": "{{stack.blockTime}}",
                "--attestation-provider": "none"
              },
              timeout: 5e3
            }
          },
          testing: {
            mocha: {},
            spawnStack: true,
            stackLogOutput: false,
            blockTime: 100,
            envSetup: {
              setup: {
                custom: void 0,
                timeout: 60 * 1e3
              },
              teardown: {
                custom: void 0,
                timeout: 10 * 1e3
              }
            }
          },
          networks: {
            local: {
              nodeUrl: "ws://localhost:{{stack.node.port}}",
              nodeApiOptions: {
                types: {
                  ...import_typedefs.khalaDev,
                  ...import_sdk.types
                }
              },
              workerUrl: "http://localhost:{{stack.pruntime.port}}",
              blockTime: 6e3
            }
          },
          accountsConfig: {
            keyrings: {
              alice: "//Alice",
              bob: "//Bob",
              charlie: "//Charlie",
              dave: "//Dave",
              eve: "//Eve",
              ferdie: "//Ferdie"
            },
            suAccount: "alice"
          }
        }, options);
        config.stack.version = await this._stackBinaryDownloader.uniformStackVersion(config.stack.version);
        if (runMode === RunMode.Testing) {
          config.stack.blockTime = config.testing.blockTime;
        }
        replacePlaceholders(config, config);
        return config;
      }
    };
    RuntimeContext = _RuntimeContext;
    __name(RuntimeContext, "RuntimeContext");
    __publicField(RuntimeContext, "SINGLETON_KEY", "devphase_Context_VSffVql3bvj9aulZY5DNnRCnrEt1V27a");
    __publicField(RuntimeContext, "NETWORK_LOCAL", "local");
  }
});

// src/cli/command/accounts.ts
async function commandMain(runtimeContext) {
  const logger2 = new Logger("Accounts");
  logger2.log("Use subcommands");
}
async function commandList(runtimeContext) {
  const logger2 = new Logger("Accounts");
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const accountManager = new AccountManager(runtimeContext);
  const accountsKeyrings = await accountManager.loadAccountsKeyringsFromStorageFile();
  const accounts = await accountManager.loadAccounts(accountsKeyrings, runtimeContext.config.general.ss58Format, false);
  const tableData = [
    [
      import_chalk7.default.bold.white("Alias"),
      import_chalk7.default.bold.white("Address"),
      import_chalk7.default.bold.white("Protection")
    ]
  ];
  for (const [alias, account] of Object.entries(accounts)) {
    tableData.push([
      import_chalk7.default.cyan(alias),
      account.address,
      account.isLocked ? import_chalk7.default.green("Password") : import_chalk7.default.yellow("Unprotected")
    ]);
  }
  logger2.log("List of accounts");
  console.log((0, import_table.table)(tableData));
}
async function commandCreate(runtimeContext) {
  const logger2 = new Logger("Accounts");
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const accountManager = new AccountManager(runtimeContext);
  const accountsKeyrings = await accountManager.loadAccountsKeyringsFromStorageFile();
  const accounts = await accountManager.loadAccounts(accountsKeyrings, runtimeContext.config.general.ss58Format, false);
  const account = await accountManager.createAccount(runtimeContext.config.general.ss58Format);
  logger2.log("Created account");
  console.log(import_chalk7.default.cyan(account.alias));
  console.log(account.keyring.address);
}
function accountsCommand(program, context) {
  const mainCommand = program.command("account").description("Accounts management").action(() => commandMain(context));
  mainCommand.command("list").description("Display accounts list").action(() => commandList(context));
  mainCommand.command("create").description("Create new account").action(() => commandCreate(context));
}
var import_chalk7, import_table;
var init_accounts = __esm({
  "src/cli/command/accounts.ts"() {
    "use strict";
    init_def();
    init_AccountManager();
    init_Logger();
    import_chalk7 = __toESM(require("chalk"));
    import_table = require("table");
    __name(commandMain, "commandMain");
    __name(commandList, "commandList");
    __name(commandCreate, "commandCreate");
    __name(accountsCommand, "accountsCommand");
  }
});

// src/service/project/Compiler.ts
var import_chalk8, import_child_process, fs6, import_path6, Compiler;
var init_Compiler = __esm({
  "src/service/project/Compiler.ts"() {
    "use strict";
    init_Logger();
    import_chalk8 = __toESM(require("chalk"));
    import_child_process = __toESM(require("child_process"));
    fs6 = __toESM(require("fs"));
    import_path6 = __toESM(require("path"));
    Compiler = class {
      constructor(_runtimeContext) {
        this._runtimeContext = _runtimeContext;
        this._logger = new Logger(Compiler.name);
      }
      async compile(contractName, releaseMode) {
        const contractPath = import_path6.default.join(this._runtimeContext.paths.contracts, contractName);
        const artifactsDirPath = import_path6.default.join(this._runtimeContext.paths.artifacts, contractName);
        this._logger.log("Building:", import_chalk8.default.blueBright(contractName));
        const args = [
          "+nightly",
          "contract",
          "build"
        ];
        if (releaseMode) {
          args.push("--release");
        }
        const child = await import_child_process.default.spawn("cargo", args, {
          cwd: contractPath
        });
        let outputDirectory;
        const analyzeOutput = /* @__PURE__ */ __name((text) => {
          const lines = text.split("\n").map((line) => line.trim());
          const lineIdx = lines.findIndex((line) => line.includes("Your contract artifacts are ready"));
          if (lineIdx !== -1) {
            outputDirectory = lines[lineIdx + 1];
          }
          process.stdout.write(text);
        }, "analyzeOutput");
        child.stdout.setEncoding("utf-8");
        child.stderr.setEncoding("utf-8");
        child.stdout.on("data", analyzeOutput);
        child.stderr.on("data", analyzeOutput);
        const resultCode = await new Promise((resolve) => {
          child.on("exit", (code) => resolve(code));
        });
        if (resultCode !== 0) {
          this._logger.error("Failed building contract");
          return false;
        }
        if (!outputDirectory) {
          this._logger.error("Unable to detect output directory");
          return false;
        }
        if (!fs6.existsSync(artifactsDirPath)) {
          fs6.mkdirSync(artifactsDirPath, {
            recursive: true
          });
        }
        this._logger.log("Files generated under:");
        const artifactFiles = [
          `${contractName}.contract`,
          `${contractName}.wasm`,
          "metadata.json"
        ];
        for (const artifactFile of artifactFiles) {
          const sourceArtifactFilePath = import_path6.default.join(outputDirectory, artifactFile);
          if (!fs6.existsSync(sourceArtifactFilePath)) {
            this._logger.error("File", artifactFile, "not generated under", sourceArtifactFilePath);
            return false;
          }
          const artifactFilePath = import_path6.default.join(artifactsDirPath, artifactFile);
          fs6.copyFileSync(sourceArtifactFilePath, artifactFilePath);
          console.log(import_path6.default.relative(this._runtimeContext.paths.project, artifactFilePath));
        }
        return true;
      }
    };
    __name(Compiler, "Compiler");
  }
});

// src/service/project/MultiContractExecutor.ts
var import_chalk9, import_chokidar, import_glob, import_path7, MultiContractExecutor;
var init_MultiContractExecutor = __esm({
  "src/service/project/MultiContractExecutor.ts"() {
    "use strict";
    init_Exception();
    init_Logger();
    import_chalk9 = __toESM(require("chalk"));
    import_chokidar = __toESM(require("chokidar"));
    import_glob = __toESM(require("glob"));
    import_path7 = __toESM(require("path"));
    MultiContractExecutor = class {
      constructor(runtimeContext) {
        this.runtimeContext = runtimeContext;
        this._logger = new Logger(MultiContractExecutor.name);
      }
      async exec(contractName, watch, callback) {
        if (contractName) {
          this._logger.log("Criteria:", import_chalk9.default.cyan(contractName));
        } else {
          this._logger.log("Criteria:", import_chalk9.default.yellow("any"));
        }
        const matchedContracts = this.matchContracts(contractName);
        this._logger.log("Matched contracts:", matchedContracts);
        if (!matchedContracts.length) {
          this._logger.log("Nothing to do");
          return;
        }
        for (const contract of matchedContracts) {
          const result = await callback(contract);
          if (!result) {
            throw new Exception(`Unable to execute action for ${contract} contract`, 1667022951192);
          }
        }
        if (watch) {
          const contractsBasePath = this.runtimeContext.paths.contracts;
          const patternsToWatch = matchedContracts.map((contract) => {
            return import_path7.default.join(contractsBasePath, contract);
          });
          const patternsToIgnore = matchedContracts.map((contract) => {
            return import_path7.default.join(contractsBasePath, contract, "target");
          });
          const watcher = import_chokidar.default.watch(patternsToWatch, {
            ignored: patternsToIgnore
          });
          watcher.on("change", (_path, stats) => {
            const relPath = import_path7.default.relative(contractsBasePath, _path);
            const contractName2 = relPath.split("/")[0];
            this._logger.log("Change detected in", import_chalk9.default.blueBright(contractName2));
            callback(contractName2);
          });
        }
      }
      matchContracts(contractName) {
        const allContracts = import_glob.default.sync("*", {
          cwd: this.runtimeContext.paths.contracts
        });
        if (contractName) {
          return allContracts.filter((contract) => contract.toLowerCase() === contractName.toLowerCase());
        } else {
          return allContracts;
        }
      }
    };
    __name(MultiContractExecutor, "MultiContractExecutor");
  }
});

// src/service/type-binding/StructTypeBuilder.ts
var import_camelCase, import_upperFirst, TsMorph, StructTypeBuilder;
var init_StructTypeBuilder = __esm({
  "src/service/type-binding/StructTypeBuilder.ts"() {
    "use strict";
    init_Exception();
    import_camelCase = __toESM(require("lodash/camelCase"));
    import_upperFirst = __toESM(require("lodash/upperFirst"));
    TsMorph = __toESM(require("ts-morph"));
    StructTypeBuilder = class {
      _builtTypes = {};
      _typeStatements = {};
      _newTypeIdx = 0;
      constructor(types) {
        this._definedTypes = Object.fromEntries(types.map((typeDef) => {
          return [
            typeDef.id,
            {
              kind: Object.keys(typeDef.type.def)[0],
              meta: typeDef.type
            }
          ];
        }));
      }
      build() {
        for (const [idx, typeDef] of Object.entries(this._definedTypes)) {
          if (!this._builtTypes[idx]) {
            this.buildType(Number(idx));
          }
        }
        return this._builtTypes;
      }
      getNativeType(typeIdx) {
        if (!this._builtTypes[typeIdx]) {
          throw new Exception("Unknown type", 1667305507276);
        }
        return this._builtTypes[typeIdx].native;
      }
      getCodecType(typeIdx) {
        if (!this._builtTypes[typeIdx]) {
          throw new Exception("Unknown type", 1667305512350);
        }
        return this._builtTypes[typeIdx].codec;
      }
      getTypeStatements() {
        return Object.values(this._typeStatements);
      }
      getArgsString(args) {
        if (args.length === 0) {
          return "never[]";
        } else {
          const argTypes = args.map((arg) => this.getNativeType(arg.type.type));
          return "[" + argTypes.join(", ") + "]";
        }
      }
      buildType(typeIdx) {
        const typeDef = this._definedTypes[typeIdx];
        if (this._builtTypes[typeIdx]) {
          return this._builtTypes[typeIdx];
        }
        if (typeDef.kind === "primitive") {
          this._builtTypes[typeIdx] = this.buildPrimitive(typeDef.meta);
        } else if (typeDef.kind === "array") {
          this._builtTypes[typeIdx] = this.buildArray(typeDef.meta);
        } else if (typeDef.kind === "sequence") {
          this._builtTypes[typeIdx] = this.buildSequence(typeDef.meta);
        } else if (typeDef.kind === "composite") {
          this._builtTypes[typeIdx] = this.buildComposite(typeDef.meta);
        } else if (typeDef.kind === "variant") {
          this._builtTypes[typeIdx] = this.buildVariant(typeDef.meta);
        } else if (typeDef.kind === "tuple") {
          this._builtTypes[typeIdx] = this.buildTuple(typeDef.meta);
        } else {
          throw new Exception(`Unknown type ${typeDef.kind}@${typeIdx}`, 1667305662214);
        }
        return this._builtTypes[typeIdx];
      }
      buildPrimitive(typeDef) {
        const { primitive } = typeDef.def;
        if (primitive === "bool") {
          return {
            native: "boolean",
            codec: "DPT.IJson<boolean>"
          };
        } else if ([
          "u8",
          "u16",
          "u32",
          "u64",
          "u128",
          "i8",
          "i16",
          "i32",
          "i64",
          "i128"
        ].includes(primitive)) {
          return {
            native: "number",
            codec: "DPT.INumber"
          };
        } else if ([
          "str"
        ].includes(primitive)) {
          return {
            native: "string",
            codec: "DPT.IText"
          };
        } else {
          throw new Exception("Unknown type", 1667223448403);
        }
      }
      buildArray(typeDef) {
        const { array: { len, type } } = typeDef.def;
        const { native, codec } = this.buildType(type);
        return {
          native: `DPT.FixedArray<${native}, ${len}>`,
          codec: `DPT.IVec<${codec}>`
        };
      }
      buildSequence(typeDef) {
        const { sequence: { type } } = typeDef.def;
        const { native, codec } = this.buildType(type);
        return {
          native: `${native}[]`,
          codec: `DPT.IVec<${codec}>`
        };
      }
      buildComposite(typeDef) {
        const { def: { composite: { fields } }, path: path14 } = typeDef;
        const compositeName = path14 ? this.getTypeNameFromPath(path14) : "Composite" + ++this._newTypeIdx;
        let declaration;
        const isSimpleObject = fields.find((field) => !field.name) === void 0;
        if (isSimpleObject) {
          const strFields = fields.map((field) => {
            const { native } = this.buildType(field.type);
            return field.name + ": " + native;
          }).join(", ");
          declaration = {
            kind: TsMorph.StructureKind.TypeAlias,
            name: compositeName,
            type: "{ " + strFields + " }"
          };
        } else {
          declaration = {
            kind: TsMorph.StructureKind.TypeAlias,
            name: compositeName,
            type: "any"
          };
        }
        this._typeStatements[compositeName] = declaration;
        return {
          native: compositeName,
          codec: `DPT.IJson<${compositeName}>`
        };
      }
      buildVariant(typeDef) {
        const { def: { variant: { variants } }, params, path: path14 } = typeDef;
        const variantName = path14 ? this.getTypeNameFromPath(path14) : "Variant" + ++this._newTypeIdx;
        const builtVariants = [];
        if (variants) {
          for (const variant of variants) {
            const { name, fields } = variant;
            let innerType;
            if (!(fields == null ? void 0 : fields.length)) {
              innerType = "null";
            } else if (fields.length === 1) {
              const { native } = this.buildType(fields[0].type);
              innerType = native;
            } else {
              const tupleParts = fields.map((field) => {
                const { native } = this.buildType(fields[0].type);
                return native;
              }).join(", ");
              innerType = "[" + tupleParts + "]";
            }
            builtVariants.push(`{ ${name}: ${innerType} }`);
          }
        } else {
          builtVariants.push("{}");
        }
        let declaration = {
          kind: TsMorph.StructureKind.TypeAlias,
          name: variantName,
          type: builtVariants.join(" | ")
        };
        this._typeStatements[variantName] = declaration;
        return {
          native: variantName,
          codec: `DPT.IJson<${variantName}>`
        };
      }
      buildTuple(typeDef) {
        const name = "Tuple" + ++this._newTypeIdx;
        const types = typeDef.def.tuple.map((type) => this.buildType(type));
        const nativeTypes = types.map((type) => type.native).join(", ");
        const codecTypes = types.map((type) => type.codec).join(", ");
        return {
          native: nativeTypes ? `[ ${nativeTypes} ]` : "never[]",
          codec: `DPT.ITuple<[ ${codecTypes} ]>`
        };
      }
      getTypeNameFromPath(path14) {
        return path14.map((part) => (0, import_upperFirst.default)((0, import_camelCase.default)(part))).join("_");
      }
    };
    __name(StructTypeBuilder, "StructTypeBuilder");
  }
});

// src/service/type-binding/AbiTypeBindingProcessor.ts
var import_camelCase2, import_upperFirst2, import_path8, TsMorph2, AbiTypeBindingProcessor;
var init_AbiTypeBindingProcessor = __esm({
  "src/service/type-binding/AbiTypeBindingProcessor.ts"() {
    "use strict";
    init_StructTypeBuilder();
    import_camelCase2 = __toESM(require("lodash/camelCase"));
    import_upperFirst2 = __toESM(require("lodash/upperFirst"));
    import_path8 = __toESM(require("path"));
    TsMorph2 = __toESM(require("ts-morph"));
    AbiTypeBindingProcessor = class {
      constructor(_abi) {
        this._abi = _abi;
        this.structTypeBuilder = new StructTypeBuilder(this._abi.types);
        this.structTypeBuilder.build();
      }
      static async createTypeBindingFile(filePath, contractName, abi) {
        const projectPath = import_path8.default.basename(filePath);
        const project = new TsMorph2.Project({
          compilerOptions: {
            rootDir: projectPath
          }
        });
        const file = project.createSourceFile(filePath, void 0, {
          overwrite: true
        });
        const context = new AbiTypeBindingProcessor(abi);
        file.addStatements(context.getImportStatements());
        file.addModule({
          isExported: true,
          name: contractName,
          statements: [
            ...context.structTypeBuilder.getTypeStatements(),
            ...context.buildMapMessageQueryInterface(),
            ...context.buildMapMessageTxInterface(),
            ...context.buildContractClass(),
            ...context.buildFactoryClass()
          ]
        });
        file.saveSync();
      }
      getImportStatements() {
        return [
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namespaceImport: "PhalaSdk",
            moduleSpecifier: "@phala/sdk"
          },
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namespaceImport: "DevPhase",
            moduleSpecifier: "devphase"
          },
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namespaceImport: "DPT",
            moduleSpecifier: "devphase/etc/typings"
          },
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namedImports: [
              "ContractCallResult",
              "ContractQuery"
            ],
            moduleSpecifier: "@polkadot/api-contract/base/types"
          },
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namedImports: [
              "ContractCallOutcome",
              "ContractOptions"
            ],
            moduleSpecifier: "@polkadot/api-contract/types"
          },
          {
            kind: TsMorph2.StructureKind.ImportDeclaration,
            isTypeOnly: true,
            namedImports: [
              "Codec"
            ],
            moduleSpecifier: "@polkadot/types/types"
          }
        ];
      }
      buildMapMessageQueryInterface() {
        const queriesModuleInterfaces = [];
        const queryMessages = this._abi.spec.messages.filter((message) => message.mutates === false);
        for (const queryMessage of queryMessages) {
          const name = this.formatInterfaceName(queryMessage.label);
          const returnType = this.structTypeBuilder.getCodecType(queryMessage.returnType.type);
          queriesModuleInterfaces.push({
            isExported: true,
            kind: TsMorph2.StructureKind.Interface,
            name,
            extends: [
              "DPT.ContractQuery"
            ],
            callSignatures: [
              {
                kind: TsMorph2.StructureKind.CallSignature,
                parameters: [
                  {
                    kind: TsMorph2.StructureKind.Parameter,
                    name: "certificateData",
                    type: "PhalaSdk.CertificateData"
                  },
                  {
                    kind: TsMorph2.StructureKind.Parameter,
                    name: "options",
                    type: "ContractOptions"
                  },
                  ...queryMessage.args.map((arg) => ({
                    kind: TsMorph2.StructureKind.Parameter,
                    name: arg.label,
                    type: this.structTypeBuilder.getNativeType(arg.type.type)
                  }))
                ],
                returnType: `DPT.CallResult<DPT.CallOutcome<${returnType}>>`
              }
            ]
          });
        }
        return [
          {
            docs: [
              "",
              "Queries",
              ""
            ],
            kind: TsMorph2.StructureKind.Module,
            name: "ContractQuery",
            statements: queriesModuleInterfaces
          },
          {
            isExported: true,
            kind: TsMorph2.StructureKind.Interface,
            name: "MapMessageQuery",
            extends: [
              "DPT.MapMessageQuery"
            ],
            properties: this._abi.spec.messages.filter((message) => message.mutates === false).map((message) => ({
              kind: TsMorph2.StructureKind.PropertySignature,
              name: this.formatContractMethodName(message.label),
              type: "ContractQuery." + this.formatInterfaceName(message.label)
            }))
          }
        ];
      }
      buildMapMessageTxInterface() {
        const txsModuleInterfaces = [];
        const txMessages = this._abi.spec.messages.filter((message) => message.mutates === true);
        for (const txMessage of txMessages) {
          const name = this.formatInterfaceName(txMessage.label);
          txsModuleInterfaces.push({
            isExported: true,
            kind: TsMorph2.StructureKind.Interface,
            name,
            extends: [
              "DPT.ContractTx"
            ],
            callSignatures: [
              {
                kind: TsMorph2.StructureKind.CallSignature,
                parameters: [
                  {
                    kind: TsMorph2.StructureKind.Parameter,
                    name: "options",
                    type: "ContractOptions"
                  },
                  ...txMessage.args.map((arg) => ({
                    kind: TsMorph2.StructureKind.Parameter,
                    name: arg.label,
                    type: this.structTypeBuilder.getNativeType(arg.type.type)
                  }))
                ],
                returnType: "DPT.SubmittableExtrinsic"
              }
            ]
          });
        }
        return [
          {
            docs: [
              "",
              "Transactions",
              ""
            ],
            kind: TsMorph2.StructureKind.Module,
            name: "ContractTx",
            statements: txsModuleInterfaces
          },
          {
            isExported: true,
            kind: TsMorph2.StructureKind.Interface,
            name: "MapMessageTx",
            extends: [
              "DPT.MapMessageTx"
            ],
            properties: this._abi.spec.messages.filter((message) => message.mutates === true).map((message) => ({
              kind: TsMorph2.StructureKind.PropertySignature,
              name: this.formatContractMethodName(message.label),
              type: "ContractTx." + this.formatInterfaceName(message.label)
            }))
          }
        ];
      }
      buildContractClass() {
        return [
          {
            docs: [
              "",
              "Contract",
              ""
            ],
            isExported: true,
            hasDeclareKeyword: true,
            kind: TsMorph2.StructureKind.Class,
            name: "Contract",
            extends: "DPT.Contract",
            getAccessors: [
              {
                name: "query",
                returnType: "MapMessageQuery"
              },
              {
                name: "tx",
                returnType: "MapMessageTx"
              }
            ]
          }
        ];
      }
      buildFactoryClass() {
        return [
          {
            docs: [
              "",
              "Contract factory",
              ""
            ],
            isExported: true,
            hasDeclareKeyword: true,
            kind: TsMorph2.StructureKind.Class,
            name: "Factory",
            extends: "DevPhase.ContractFactory",
            methods: this._abi.spec.constructors.map((constructor) => ({
              name: "instantiate",
              typeParameters: [
                {
                  name: "T",
                  default: "Contract"
                }
              ],
              parameters: [
                {
                  name: "constructor",
                  type: `"${constructor.label}"`
                },
                {
                  name: "params",
                  type: this.structTypeBuilder.getArgsString(constructor.args)
                },
                {
                  name: "options",
                  hasQuestionToken: true,
                  type: "DevPhase.InstantiateOptions"
                }
              ],
              returnType: "Promise<T>"
            }))
          }
        ];
      }
      formatInterfaceName(label) {
        return label.split("::").map((part) => (0, import_upperFirst2.default)((0, import_camelCase2.default)(part))).join("_");
      }
      formatContractMethodName(label) {
        const methodName = label.split("::").map((part) => (0, import_camelCase2.default)(part)).join("::");
        return methodName.includes("::") ? `'${methodName}'` : methodName;
      }
    };
    __name(AbiTypeBindingProcessor, "AbiTypeBindingProcessor");
  }
});

// src/service/project/TypeBinder.ts
var import_chalk10, fs7, import_camelCase3, import_upperFirst3, import_path9, TypeBinder;
var init_TypeBinder = __esm({
  "src/service/project/TypeBinder.ts"() {
    "use strict";
    init_AbiTypeBindingProcessor();
    init_Exception();
    init_Logger();
    import_chalk10 = __toESM(require("chalk"));
    fs7 = __toESM(require("fs"));
    import_camelCase3 = __toESM(require("lodash/camelCase"));
    import_upperFirst3 = __toESM(require("lodash/upperFirst"));
    import_path9 = __toESM(require("path"));
    TypeBinder = class {
      constructor(runtimeContext) {
        this.runtimeContext = runtimeContext;
        this._logger = new Logger(TypeBinder.name);
      }
      async createBindings(contractName) {
        this._logger.log("Generating type bindings for:", import_chalk10.default.blueBright(contractName));
        const artifactsPath = import_path9.default.join(this.runtimeContext.paths.artifacts, contractName);
        const metadataFilePath = import_path9.default.join(artifactsPath, "metadata.json");
        if (!fs7.existsSync(metadataFilePath)) {
          throw new Exception("Metadata file not found", 1667222247617);
        }
        const metadataRaw = fs7.readFileSync(metadataFilePath, {
          encoding: "utf-8"
        });
        const metadata = JSON.parse(metadataRaw);
        if (!metadata.V3) {
          throw new Exception("Only V3 metadata is supported", 1667022489434);
        }
        const abi = metadata.V3;
        const pcContractName = (0, import_upperFirst3.default)((0, import_camelCase3.default)(metadata.contract.name));
        const typingsBasePath = this.runtimeContext.paths.typings;
        if (!fs7.existsSync(typingsBasePath)) {
          fs7.mkdirSync(typingsBasePath, {
            recursive: true
          });
        }
        const filePath = import_path9.default.join(typingsBasePath, `${pcContractName}.ts`);
        await AbiTypeBindingProcessor.createTypeBindingFile(filePath, pcContractName, abi);
        return true;
      }
    };
    __name(TypeBinder, "TypeBinder");
  }
});

// src/service/project/ContractManager.ts
var import_fs6, import_lodash, import_path10, import_prompts2, _ContractManager, ContractManager;
var init_ContractManager = __esm({
  "src/service/project/ContractManager.ts"() {
    "use strict";
    init_def();
    init_Compiler();
    init_MultiContractExecutor();
    init_RuntimeContext();
    init_TypeBinder();
    init_Exception();
    init_Logger();
    import_fs6 = __toESM(require("fs"));
    import_lodash = __toESM(require("lodash"));
    import_path10 = __toESM(require("path"));
    import_prompts2 = __toESM(require("prompts"));
    _ContractManager = class {
      constructor(_runtimeContext) {
        this._runtimeContext = _runtimeContext;
        this._logger = new Logger(_ContractManager.name);
      }
      async loadContractsDefFromStorageFile() {
        const contractsStoragePath = import_path10.default.join(this._runtimeContext.paths.project, "contracts.json");
        if (!import_fs6.default.existsSync(contractsStoragePath)) {
          return null;
        }
        return JSON.parse(import_fs6.default.readFileSync(contractsStoragePath, {
          encoding: "utf-8"
        }));
      }
      async _addContractDefToStorageFile(contractDef) {
        const contractsStoragePath = import_path10.default.join(this._runtimeContext.paths.project, "contracts.json");
        let currentData = await this.loadContractsDefFromStorageFile();
        if (!currentData) {
          currentData = [];
        }
        currentData.push(contractDef);
        const outData = JSON.stringify(currentData);
        import_fs6.default.writeFileSync(contractsStoragePath, outData, {
          encoding: "utf-8"
        });
      }
      async loadContract(contractDef) {
        const devPhase = this._runtimeContext.getDevPhase();
        const contractFactory = await devPhase.getFactory(contractDef.type, contractDef.name, {
          clusterId: contractDef.clusterId
        });
        return contractFactory.attach(contractDef.contractId);
      }
      async createNew(options) {
        const contractNameValidator = /* @__PURE__ */ __name((name) => /^[a-z][a-z0-9_]+$/.test(name), "contractNameValidator");
        if (!options.name) {
          const { name } = await (0, import_prompts2.default)({
            type: "text",
            name: "name",
            message: `Contract name:`,
            validate: contractNameValidator
          });
          options.name = name;
        }
        if (!contractNameValidator(options.name)) {
          throw new Exception("Unallowed characters in contract name", 1673533712922);
        }
        const templatePath = import_path10.default.join(this._runtimeContext.paths.templates, "contract");
        const targetContractPath = import_path10.default.join(this._runtimeContext.paths.contracts, options.name);
        if (import_fs6.default.existsSync(targetContractPath)) {
          throw new Exception("Contract already exists", 1673534385418);
        }
        import_fs6.default.cpSync(templatePath, targetContractPath, {
          recursive: true
        });
        const placeholders = {
          "{{contract_name}}": options.name,
          "{{ContractName}}": import_lodash.default.startCase(import_lodash.default.camelCase(options.name))
        };
        for (const file of _ContractManager.TEMPLATE_FILES) {
          const filePath = import_path10.default.join(targetContractPath, file);
          await this._replacePlaceholdersInFile(filePath, placeholders);
        }
        this._logger.log("Contract created in", targetContractPath);
      }
      async _replacePlaceholdersInFile(filePath, placeholders) {
        let fileData = import_fs6.default.readFileSync(filePath, {
          encoding: "utf-8"
        });
        for (const [placeholder, value] of Object.entries(placeholders)) {
          fileData = fileData.replaceAll(placeholder, value);
        }
        import_fs6.default.writeFileSync(filePath, fileData, {
          encoding: "utf-8"
        });
      }
      async compile(options) {
        this._logger.log("Contracts compilation");
        const contractCompiler = new Compiler(this._runtimeContext);
        const typeBinder = new TypeBinder(this._runtimeContext);
        const multiContractExecutor = new MultiContractExecutor(this._runtimeContext);
        return multiContractExecutor.exec(options.contractName, options.watch, async (contractName) => {
          const result = await contractCompiler.compile(contractName, options.release);
          if (!result) {
            return false;
          }
          return typeBinder.createBindings(contractName);
        });
      }
      async deploy(contractName, constructor, ctorArgs, options) {
        options = {
          network: RuntimeContext.NETWORK_LOCAL,
          contractType: ContractType.InkCode,
          ...options
        };
        const devPhase = await this._runtimeContext.initDevPhase(options.network);
        const contractFactory = await devPhase.getFactory(options.contractType, contractName, {
          clusterId: options.clusterId
        });
        const deployOptions = {};
        if (options.account) {
          deployOptions.asAccount = options.account;
        }
        await contractFactory.deploy(deployOptions);
        const instantiateOptions = {};
        if (options.account) {
          instantiateOptions.asAccount = options.account;
        }
        const instance = await contractFactory.instantiate(constructor, ctorArgs, instantiateOptions);
        await this._addContractDefToStorageFile({
          name: contractName,
          network: options.network,
          contractId: instance.contractId,
          type: options.contractType,
          clusterId: instance.clusterId
        });
        this._logger.log("Contract deployed");
        console.log("Contract Id:", instance.contractId);
        console.log("Cluster Id: ", instance.clusterId);
        await devPhase.cleanup();
      }
      async contractCall(options) {
      }
    };
    ContractManager = _ContractManager;
    __name(ContractManager, "ContractManager");
    __publicField(ContractManager, "TEMPLATE_FILES", [
      "Cargo.toml",
      "lib.rs"
    ]);
  }
});

// src/cli/command/contracts.ts
async function commandMain2(runtimeContext) {
  console.log("Use subcommands");
}
async function commandList2(runtimeContext) {
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const contractManager = new ContractManager(runtimeContext);
  let contractDefinitions = await contractManager.loadContractsDefFromStorageFile();
  contractDefinitions = (0, import_sortBy.default)(contractDefinitions, [
    "type",
    "network",
    "name"
  ]);
  let tableData = [
    [
      import_chalk11.default.bold.white("Name"),
      import_chalk11.default.bold.white("Type"),
      import_chalk11.default.bold.white("Network"),
      import_chalk11.default.bold.white("Contract Id"),
      import_chalk11.default.bold.white("Cluster Id")
    ]
  ];
  for (const contractDefinition of contractDefinitions) {
    tableData.push([
      import_chalk11.default.cyan(contractDefinition.name),
      contractDefinition.type,
      contractDefinition.network,
      contractDefinition.contractId,
      contractDefinition.clusterId
    ]);
  }
  console.log("List of contracts");
  console.log((0, import_table2.table)(tableData));
}
async function commandNew(runtimeContext, createNewOptions) {
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const contractManager = new ContractManager(runtimeContext);
  await contractManager.createNew(createNewOptions);
}
async function commandCompile(runtimeContext, compileOptions) {
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const contractManager = new ContractManager(runtimeContext);
  await contractManager.compile(compileOptions);
}
async function commandDeploy(runtimeContext, contractName, constructor, ctorArgs, deployOptions) {
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const contractManager = new ContractManager(runtimeContext);
  await contractManager.deploy(contractName, constructor, ctorArgs, deployOptions);
}
async function commandCall(runtimeContext, callOptions) {
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const contractManager = new ContractManager(runtimeContext);
  await contractManager.contractCall(callOptions);
}
function contractsCommand(program, context) {
  const mainCommand = program.command("contract").description("Contracts management").action(() => commandMain2(context));
  mainCommand.command("list").description("Display contract list").action(() => commandList2(context));
  mainCommand.command("new").description("Create new contract").option("-n, --name <name>", "Contract name").action((contractCreateNewOptions) => commandNew(context, contractCreateNewOptions));
  mainCommand.command("compile").description("Compile contract(s)").option("-c, --contract <contractName>", "Optional name of contract(s) to compile").option("-w, --watch", "Watch for changes", false).option("-r, --release", "Compile in release mode", false).action((contractCompileOptions) => commandCompile(context, contractCompileOptions));
  mainCommand.command("deploy").description("Deploy contract").argument("contractName", "Contract name").argument("constructor", "Contract constructor").option("-t, --type <contractType>", "Contract type (InkCode default)").option("-n, --network <network>", "Target network to deploy (local default)").option("-l, --cluster <network>", "Target cluster Id").option("-a, --account <account>", "Account used to deploy").argument("[ctorArgs...]", "Contract constructor arguments").action((contractName, constructor, ctorArgs, deployOptions) => {
    return commandDeploy(context, contractName, constructor, ctorArgs, deployOptions);
  });
  mainCommand.command("call").description("Call contract method").option("-c, --contract <contractName>", "Optional name of contract(s) to compile").action((callOptions) => commandCall(context, callOptions));
}
var import_chalk11, import_sortBy, import_table2;
var init_contracts = __esm({
  "src/cli/command/contracts.ts"() {
    "use strict";
    init_def();
    init_ContractManager();
    import_chalk11 = __toESM(require("chalk"));
    import_sortBy = __toESM(require("lodash/sortBy"));
    import_table2 = require("table");
    __name(commandMain2, "commandMain");
    __name(commandList2, "commandList");
    __name(commandNew, "commandNew");
    __name(commandCompile, "commandCompile");
    __name(commandDeploy, "commandDeploy");
    __name(commandCall, "commandCall");
    __name(contractsCommand, "contractsCommand");
  }
});

// src/service/project/Initializer.ts
var import_chalk12, import_fs7, import_path11, Initializer;
var init_Initializer = __esm({
  "src/service/project/Initializer.ts"() {
    "use strict";
    init_Logger();
    import_chalk12 = __toESM(require("chalk"));
    import_fs7 = __toESM(require("fs"));
    import_path11 = __toESM(require("path"));
    Initializer = class {
      constructor(_runtimeContext) {
        this._runtimeContext = _runtimeContext;
        this._logger = new Logger(Initializer.name);
        this._templates = {
          "gitignore": ".gitignore",
          "accounts.json": "accounts.json",
          "devphase.config.ts": "devphase.config.ts"
        };
        this._directories = [
          "contracts",
          "tests"
        ];
      }
      async init() {
        const inProjectDirectory = await this._runtimeContext.isInProjectDirectory();
        if (inProjectDirectory) {
          this._logger.log("Project already initiated");
          return true;
        }
        this._logger.log("Creating files");
        for (const [fromTemplateFile, toTemplateFile] of Object.entries(this._templates)) {
          const sourceTemplatePath = import_path11.default.join(this._runtimeContext.paths.templates, fromTemplateFile);
          const targetFilePath = `./${toTemplateFile}`;
          if (import_fs7.default.existsSync(targetFilePath)) {
            continue;
          }
          this._logger.log(import_chalk12.default.cyan(toTemplateFile));
          import_fs7.default.copyFileSync(sourceTemplatePath, targetFilePath);
        }
        this._logger.log("Creating directories");
        for (const directory of this._directories) {
          const targetDirectoryPath = `./${directory}`;
          if (import_fs7.default.existsSync(targetDirectoryPath)) {
            continue;
          }
          this._logger.log(import_chalk12.default.cyan(directory));
          import_fs7.default.mkdirSync(targetDirectoryPath);
        }
        return true;
      }
    };
    __name(Initializer, "Initializer");
  }
});

// src/cli/command/init.ts
async function command(runtimeContext) {
  const logger2 = new Logger("Init");
  logger2.log("Initiation");
  await runtimeContext.initContext(RunMode.Simple);
  const initializer = new Initializer(runtimeContext);
  await initializer.init();
}
function initCommand(program, context) {
  program.command("init").description("Initialize project").action(async () => command(context));
}
var init_init = __esm({
  "src/cli/command/init.ts"() {
    "use strict";
    init_def();
    init_Initializer();
    init_Logger();
    __name(command, "command");
    __name(initCommand, "initCommand");
  }
});

// src/utils/serializeProcessArgs.ts
function serializeProcessArgs(args) {
  const serialized = [];
  for (const [name, value] of Object.entries(args)) {
    if ([
      void 0,
      null,
      false
    ].includes(value)) {
      continue;
    } else if (value === true) {
      serialized.push(name);
    } else {
      serialized.push(name + "=" + value);
    }
  }
  return serialized;
}
var init_serializeProcessArgs = __esm({
  "src/utils/serializeProcessArgs.ts"() {
    "use strict";
    __name(serializeProcessArgs, "serializeProcessArgs");
  }
});

// src/utils/timeout.ts
function timeout(callback, timeLimit, options = {}) {
  options = {
    message: "Timeout",
    ...options
  };
  return new Promise(async (resolve, reject) => {
    const _timeout = setTimeout(() => reject(new Exception(options.message, 1663946429155)), timeLimit);
    try {
      const result = await callback();
      clearTimeout(_timeout);
      resolve(result);
    } catch (e) {
      clearTimeout(_timeout);
      reject(e);
    }
  });
}
var init_timeout = __esm({
  "src/utils/timeout.ts"() {
    "use strict";
    init_Exception();
    __name(timeout, "timeout");
  }
});

// src/service/project/StackManager.ts
var import_chalk13, import_child_process2, import_fs8, import_cloneDeep, import_path12, StackManager;
var init_StackManager = __esm({
  "src/service/project/StackManager.ts"() {
    "use strict";
    init_def();
    init_Exception();
    init_Logger();
    init_serializeProcessArgs();
    init_timeout();
    import_chalk13 = __toESM(require("chalk"));
    import_child_process2 = __toESM(require("child_process"));
    import_fs8 = __toESM(require("fs"));
    import_cloneDeep = __toESM(require("lodash/cloneDeep"));
    import_path12 = __toESM(require("path"));
    StackManager = class {
      constructor(_context) {
        this._context = _context;
        this._logger = new Logger(StackManager.name);
        this._killFlag = false;
        this._runLogsPath = this._context.paths.currentLog;
      }
      async startStack(runMode) {
        if (this._processes) {
          throw new Exception("Stack processes already started", 1666229698364);
        }
        if (this.isLogOutputUsed(runMode, this._context)) {
          import_fs8.default.mkdirSync(this._runLogsPath, {
            recursive: true
          });
        }
        this._processes = {
          node: null,
          pruntime: null,
          pherry: null
        };
        this._processes.node = await this.startNode(runMode);
        if (this._killFlag) {
          return this._processes;
        }
        this._processes.pruntime = await this.startPruntime(runMode);
        if (this._killFlag) {
          return this._processes;
        }
        this._processes.pherry = await this.startPherry(runMode);
        return this._processes;
      }
      async stopStack(force = false) {
        var _a, _b, _c, _d, _e, _f;
        this._killFlag = true;
        if (!this._processes) {
          throw new Exception("Stack was not started yet", 1666229971488);
        }
        const signal = force ? "SIGKILL" : "SIGTERM";
        if (!((_a = this._processes.pherry) == null ? void 0 : _a.killed)) {
          (_b = this._processes.pherry) == null ? void 0 : _b.kill(signal);
        }
        if (!((_c = this._processes.pruntime) == null ? void 0 : _c.killed)) {
          (_d = this._processes.pruntime) == null ? void 0 : _d.kill(signal);
        }
        if (!((_e = this._processes.node) == null ? void 0 : _e.killed)) {
          (_f = this._processes.node) == null ? void 0 : _f.kill(signal);
        }
      }
      async startNode(runMode) {
        const options = (0, import_cloneDeep.default)(this._context.config.stack.node);
        return this.startComponent("node", options, runMode, (text) => text.includes("Running JSON-RPC"), (text) => text.toLowerCase().includes("error"));
      }
      async startPruntime(runMode) {
        const options = (0, import_cloneDeep.default)(this._context.config.stack.pruntime);
        return this.startComponent("pruntime", options, runMode, (text) => text.includes("Rocket has launched from"), (text) => text.toLowerCase().includes("error"));
      }
      async startPherry(runMode) {
        const options = (0, import_cloneDeep.default)(this._context.config.stack.pherry);
        return this.startComponent("pherry", options, runMode, (text) => text.includes("pRuntime get_info response: PhactoryInfo"), (text) => text.toLowerCase().includes("error"));
      }
      async startComponent(componentName, options, runMode, waitForReady = () => true, waitForError = () => false) {
        const binaryPath = this.getComponentPath(options.binary);
        const workingDirPath = this.getComponentPath(options.workingDir);
        if (import_fs8.default.existsSync(workingDirPath)) {
          import_fs8.default.rmSync(workingDirPath, {
            recursive: true,
            force: true
          });
        }
        import_fs8.default.mkdirSync(workingDirPath, {
          recursive: true
        });
        const spawnOptions = {
          cwd: workingDirPath,
          env: {
            ...process.env,
            ...options.envs
          },
          stdio: [
            "ignore",
            "pipe",
            "pipe"
          ]
        };
        const binaryName = import_path12.default.basename(binaryPath);
        this._logger.log("Waiting for", import_chalk13.default.cyan(binaryName), "to start with", (options.timeout / 1e3).toFixed(1), "s timeout.");
        const child = import_child_process2.default.spawn(binaryPath, serializeProcessArgs(options.args), spawnOptions);
        const [stdin, stdout, stderr] = child.stdio;
        stdout.setEncoding("utf-8");
        stderr.setEncoding("utf-8");
        let logFileDscr;
        if (this.isLogOutputUsed(runMode, this._context)) {
          const logFilePath = import_path12.default.join(this._runLogsPath, `${componentName}.log`);
          logFileDscr = import_fs8.default.openSync(logFilePath, "a");
          child.on("close", () => {
            import_fs8.default.closeSync(logFileDscr);
          });
        }
        let settled = false;
        await timeout(() => {
          return new Promise((resolve, reject) => {
            const interval = setInterval(() => {
              if (this._killFlag) {
                child.kill("SIGKILL");
                cleanup();
                reject(new Exception("Component killed", 1667576698031));
              }
            }, 250);
            const cleanup = /* @__PURE__ */ __name(() => {
              settled = true;
              clearInterval(interval);
            }, "cleanup");
            const watchFn = /* @__PURE__ */ __name((chunk) => {
              const text = chunk.toString();
              if (runMode === RunMode.Simple) {
                console.log(import_chalk13.default.blueBright(`[${binaryName}]`));
                process.stdout.write(text);
              } else if (this.isLogOutputUsed(runMode, this._context)) {
                import_fs8.default.appendFileSync(logFileDscr, text, {
                  encoding: "utf-8"
                });
              }
              if (!settled) {
                if (waitForReady(text)) {
                  this._logger.log("Binary", import_chalk13.default.cyan(binaryName), "started");
                  cleanup();
                  resolve(child);
                } else if (waitForError(text)) {
                  cleanup();
                  reject(new Exception(`Failed to start ${binaryName} component`, 1666286544430));
                }
              }
            }, "watchFn");
            stdout.on("data", watchFn);
            stderr.on("data", watchFn);
          });
        }, options.timeout);
        return child;
      }
      getComponentPath(_path) {
        return import_path12.default.resolve(this._context.paths.project, _path);
      }
      isLogOutputUsed(runMode, context) {
        return runMode === RunMode.Testing && context.config.testing.stackLogOutput;
      }
    };
    __name(StackManager, "StackManager");
  }
});

// src/cli/command/stack.ts
async function command2(runtimeContext) {
  const logger2 = new Logger("Stack");
  logger2.log("Starting");
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  await runtimeContext.requestStackBinaries();
  const stackManager = new StackManager(runtimeContext);
  try {
    await stackManager.startStack(RunMode.Simple);
  } catch (e) {
    await stackManager.stopStack();
    throw e;
  }
  process.on("SIGINT", async () => {
    logger2.log("Got SIGINT - shutting down");
    await stackManager.stopStack();
  });
}
function stackCommand(program, context) {
  program.command("stack").description("Start Phala stack").action(async () => command2(context));
}
var init_stack = __esm({
  "src/cli/command/stack.ts"() {
    "use strict";
    init_def();
    init_StackManager();
    init_Logger();
    __name(command2, "command");
    __name(stackCommand, "stackCommand");
  }
});

// src/cli/command/stack-setup.ts
async function command3(runtimeContext, options) {
  const logger2 = new Logger("StackSetup");
  logger2.log("Setup started");
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const devPhase = await DevPhase.create(runtimeContext, options.network);
  const stackSetupService = new StackSetupService(devPhase);
  await stackSetupService.setupStack(runtimeContext.config.stack.setupOptions);
  await devPhase.cleanup();
  logger2.info("Stack is ready");
}
function stackSetupCommand(program, context) {
  program.command("stack:setup").description("Setup Phala stack").option("-n, --network <network>", "Network key", "local").action((options) => command3(context, options));
}
var init_stack_setup = __esm({
  "src/cli/command/stack-setup.ts"() {
    "use strict";
    init_def();
    init_DevPhase();
    init_StackSetupService();
    init_Logger();
    __name(command3, "command");
    __name(stackSetupCommand, "stackSetupCommand");
  }
});

// src/cli/command/test.ts
async function command4(runtimeContext, network) {
  const logger2 = new Logger("Test");
  logger2.log("Running tests");
  await runtimeContext.initContext(RunMode.Testing, network);
  runtimeContext.requestProjectDirectory();
  await runtimeContext.requestStackBinaries();
  const { default: Mocha } = await import("mocha");
  const mochaConfig = {
    timeout: 1e4,
    ...runtimeContext.config.testing.mocha
  };
  const mocha = new Mocha(mochaConfig);
  mocha.addFile(import_path13.default.join(runtimeContext.paths.devphase, "/etc/mocha.global.ts"));
  const patterns = [
    `${runtimeContext.config.directories.tests}/**/*.@(test|spec).@(ts|js)`
  ];
  for (const pattern of patterns) {
    const files = import_glob2.default.sync(pattern, {
      cwd: runtimeContext.paths.project
    });
    files.forEach((file) => mocha.addFile(file));
  }
  await new Promise((resolve) => {
    mocha.run(resolve);
  });
  mocha.dispose();
}
function testCommand(program, context) {
  program.command("test").description("Start tests").option("-n, --network <network>", "Network key", "local").action((options) => command4(context, options.network));
}
var import_glob2, import_path13;
var init_test = __esm({
  "src/cli/command/test.ts"() {
    "use strict";
    init_def();
    init_Logger();
    import_glob2 = __toESM(require("glob"));
    import_path13 = __toESM(require("path"));
    __name(command4, "command");
    __name(testCommand, "testCommand");
  }
});

// src/cli/command/typings.ts
async function command5(runtimeContext, contractName, options) {
  const logger2 = new Logger("Typings");
  logger2.log("Starting");
  await runtimeContext.initContext(RunMode.Simple);
  runtimeContext.requestProjectDirectory();
  const binder = new TypeBinder(runtimeContext);
  const multiContractExecutor = new MultiContractExecutor(runtimeContext);
  return multiContractExecutor.exec(contractName, options.watch, (contractName2) => {
    return binder.createBindings(contractName2);
  });
  return binder.createBindings(contractName);
}
function typeBindingsCommand(program, context) {
  program.command("typings").description("Create type bindings for contracts").argument("[contractName]", "Optional name of contract to compile", null).option("-w, --watch", "Watch for changes", false).action(async (...args) => command5(context, ...args));
}
var init_typings = __esm({
  "src/cli/command/typings.ts"() {
    "use strict";
    init_def();
    init_MultiContractExecutor();
    init_TypeBinder();
    init_Logger();
    __name(command5, "command");
    __name(typeBindingsCommand, "typeBindingsCommand");
  }
});

// src/cli/command/index.ts
var command_exports = {};
__export(command_exports, {
  accountsCommand: () => accountsCommand,
  contractsCommand: () => contractsCommand,
  initCommand: () => initCommand,
  stackCommand: () => stackCommand,
  stackSetupCommand: () => stackSetupCommand,
  testCommand: () => testCommand,
  typeBindingsCommand: () => typeBindingsCommand
});
var init_command = __esm({
  "src/cli/command/index.ts"() {
    "use strict";
    init_accounts();
    init_contracts();
    init_init();
    init_stack();
    init_stack_setup();
    init_test();
    init_typings();
  }
});

// src/cli/index.ts
init_RuntimeContext();
var import_commander = require("commander");
(async () => {
  const program = new import_commander.Command();
  program.name("devPHAse").description("Development tool for Phala Phat contracts").version("0.0.1");
  const runtimeContext = await RuntimeContext.getSingleton();
  const builtInCommands = await Promise.resolve().then(() => (init_command(), command_exports));
  for (const commandRegisterFn of Object.values(builtInCommands)) {
    await commandRegisterFn(program, runtimeContext);
  }
  program.parse();
})();
