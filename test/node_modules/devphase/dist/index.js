"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ContractFactory: () => ContractFactory,
  ContractType: () => ContractType,
  DevPhase: () => DevPhase,
  Logger: () => Logger,
  LoggerLevel: () => LoggerLevel,
  RunMode: () => RunMode,
  RuntimeContext: () => RuntimeContext,
  StackManager: () => StackManager,
  TxHandler: () => TxHandler
});
module.exports = __toCommonJS(src_exports);

// src/def.ts
var RunMode;
(function(RunMode2) {
  RunMode2["Simple"] = "Simple";
  RunMode2["Testing"] = "Testing";
})(RunMode || (RunMode = {}));
var ContractType;
(function(ContractType2) {
  ContractType2["InkCode"] = "InkCode";
  ContractType2["SidevmCode"] = "SidevmCode";
})(ContractType || (ContractType = {}));

// src/utils/Logger.ts
var import_chalk = __toESM(require("chalk"));
var LoggerLevel;
(function(LoggerLevel2) {
  LoggerLevel2[LoggerLevel2["Debug"] = 0] = "Debug";
  LoggerLevel2[LoggerLevel2["Log"] = 1] = "Log";
  LoggerLevel2[LoggerLevel2["Info"] = 2] = "Info";
  LoggerLevel2[LoggerLevel2["Warn"] = 3] = "Warn";
  LoggerLevel2[LoggerLevel2["Error"] = 4] = "Error";
  LoggerLevel2[LoggerLevel2["NoLogging"] = 5] = "NoLogging";
})(LoggerLevel || (LoggerLevel = {}));
var _Logger = class {
  constructor(serviceName) {
    this.serviceName = serviceName;
  }
  log(...args) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
      return;
    }
    const logArgs = [
      ...args
    ];
    logArgs.unshift(import_chalk.default.white(`[${this.serviceName}]`));
    console.log(...logArgs);
  }
  time(label) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
      return;
    }
    const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
    console.time(text);
  }
  timeEnd(label) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
      return;
    }
    const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
    console.timeEnd(text);
  }
  timeLog(label) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
      return;
    }
    const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
    console.timeLog(text);
  }
  timeStamp(label) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Log) {
      return;
    }
    const text = import_chalk.default.white(`[${this.serviceName}]`) + " " + label;
    console.timeStamp(text);
  }
  dir(object, options) {
    const serviceName = import_chalk.default.white(`[${this.serviceName}]`);
    console.log(serviceName);
    console.dir(object, options);
  }
  debug(...args) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Debug) {
      return;
    }
    const logArgs = [
      ...args
    ];
    logArgs.unshift(import_chalk.default.grey(`[${this.serviceName}]`));
    console.debug(...logArgs);
  }
  info(...args) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Info) {
      return;
    }
    const logArgs = [
      ...args
    ];
    logArgs.unshift(import_chalk.default.cyan(`[${this.serviceName}]`));
    console.info(...logArgs);
  }
  warn(...args) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Warn) {
      return;
    }
    const logArgs = [
      ...args
    ];
    logArgs.unshift(import_chalk.default.yellow(`[${this.serviceName}]`));
    console.warn(...logArgs);
  }
  error(...args) {
    if (_Logger.LOGGER_LEVEL > LoggerLevel.Error) {
      return;
    }
    const logArgs = [
      ...args
    ];
    logArgs.unshift(import_chalk.default.red(`[${this.serviceName}]`));
    console.error(...logArgs);
  }
};
var Logger = _Logger;
__name(Logger, "Logger");
__publicField(Logger, "LOGGER_LEVEL", LoggerLevel.Log);

// src/service/api/EventQueue.ts
var EventQueue = class {
  _handlers = {};
  async init(api) {
    this._api = api;
    this._eventsSubscription = await this._api.query.system.events((events) => this._handleEvents(events));
  }
  async destroy() {
    if (this._eventsSubscription instanceof Function) {
      await this._eventsSubscription();
    }
  }
  registerHandler(eventKey, argsFilters = {}, callee, once = true) {
    if (!this._handlers[eventKey]) {
      this._handlers[eventKey] = [];
    }
    this._handlers[eventKey].push({
      callee,
      argsFilters,
      once
    });
  }
  async _handleEvents(events) {
    var _a;
    for (const { event } of events) {
      const eventKey = event.section + "." + event.method;
      if (!((_a = this._handlers[eventKey]) == null ? void 0 : _a.length)) {
        continue;
      }
      const eventData = event.data.toJSON();
      for (const handler of this._handlers[eventKey]) {
        const matchArgs = this._checkMatchArgs(handler.argsFilters, eventData);
        if (matchArgs) {
          await handler.callee(event);
          if (handler.once) {
            handler.drop = true;
          }
        }
      }
      this._handlers[eventKey] = this._handlers[eventKey].filter((handler) => !handler.drop);
    }
  }
  _checkMatchArgs(argsFilters, args) {
    for (const [argIdx, argFilter] of Object.entries(argsFilters)) {
      const argValue = args[argIdx];
      if (argFilter instanceof Array) {
        if (!argFilter.includes(argValue)) {
          return false;
        }
      } else if (argFilter != argValue) {
        return false;
      }
    }
    return true;
  }
};
__name(EventQueue, "EventQueue");

// src/service/api/TxHandler.ts
var import_chalk2 = __toESM(require("chalk"));
var logger = new Logger("TxHandler");
var TxHandler = class {
  static async handle(transaction, keyringPair, transactionId, options) {
    return new Promise(async (resolve, reject) => {
      const unsub = await transaction.signAndSend(keyringPair, options, (result, extra) => {
        if (result.status.isReady) {
          logger.debug(transactionId + ": " + import_chalk2.default.grey("ready"));
        } else if (result.status.isBroadcast) {
          logger.debug(transactionId + ": " + import_chalk2.default.grey("brodcast"));
        } else if (result.status.isInvalid) {
          logger.debug(transactionId + ": " + import_chalk2.default.red("invalid"));
          reject(result);
        } else if (result.status.isDropped) {
          logger.debug(transactionId + ": " + import_chalk2.default.red("dropped"));
          reject(result);
        } else if (result.status.isRetracted) {
          logger.debug(transactionId + ": " + import_chalk2.default.red("retracted"));
          reject(result);
        } else if (result.status.isInBlock) {
          logger.debug(transactionId + ": " + import_chalk2.default.green("in block"));
          resolve(result);
        } else if (result.status.isUsurped) {
          logger.debug(transactionId + ": " + import_chalk2.default.green("is usurped"));
          reject(result);
        }
        if (result.status.isFinalized || result.status.isFinalityTimeout) {
          resolve(result);
          unsub();
        }
      });
    });
  }
};
__name(TxHandler, "TxHandler");

// src/utils/Exception.ts
var Exception = class extends Error {
  name = "Throwable";
  constructor(message, code = -1, error) {
    super(message);
    this.code = code;
    if (error) {
      this._initErrorMessage(this.message, error);
    }
  }
  toString() {
    return this.name + ": " + this.message;
  }
  _initErrorMessage(message, error) {
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
    const messageLines = (this.message.match(/\n/g) || []).length + 1;
    this.stack = this.constructor.name + ": [" + this.code + "] " + message + "\n" + this.stack.split("\n").slice(1, messageLines + 1).join("\n") + "\n" + error.stack;
  }
};
__name(Exception, "Exception");

// src/utils/waitFor.ts
async function waitFor(callback, timeLimit, options = {}) {
  options = {
    checkInterval: 500,
    message: "Timeout",
    ...options
  };
  let _intervalHandle = null;
  let _timeoutHandle = null;
  return new Promise((resolve, reject) => {
    _intervalHandle = setInterval(async () => {
      try {
        const result = await callback();
        if (result) {
          clearTimeout(_timeoutHandle);
          clearInterval(_intervalHandle);
          resolve(result);
        }
      } catch (e) {
        clearTimeout(_timeoutHandle);
        reject(e);
      }
    }, options.checkInterval);
    _timeoutHandle = setTimeout(() => {
      clearInterval(_intervalHandle);
      reject(new Exception(options.message, 1663946414394));
    }, timeLimit);
  });
}
__name(waitFor, "waitFor");

// src/service/api/ContractFactory.ts
var PhalaSdk = __toESM(require("@phala/sdk"));
var import_api_contract = require("@polkadot/api-contract");
var import_chalk3 = __toESM(require("chalk"));
var ContractFactory = class {
  _logger = new Logger(ContractFactory.name);
  _eventQueue = new EventQueue();
  get api() {
    return this._devPhase.api;
  }
  async init() {
    await this._eventQueue.init(this._devPhase.api);
  }
  static async create(devPhase, contractType, metadata, clusterId) {
    const instance = new ContractFactory();
    instance._devPhase = devPhase;
    if (!clusterId) {
      clusterId = devPhase.mainClusterId;
    }
    Object.assign(instance, {
      contractType,
      metadata,
      clusterId
    });
    await instance.init();
    return instance;
  }
  async deploy(options = {}) {
    options = {
      asAccount: "alice",
      ...options
    };
    await TxHandler.handle(this.api.tx.phalaFatContracts.clusterUploadResource(this.clusterId, this.contractType, this.metadata.source.wasm), this._devPhase.accounts[options.asAccount], "phalaFatContracts.clusterUploadResource");
  }
  async instantiate(constructor, params = [], options = {}) {
    options = {
      salt: 1e9 + Math.round(Math.random() * 8999999999),
      asAccount: "alice",
      transfer: 0,
      gasLimit: 1e12,
      storageDepositLimit: null,
      deposit: 0,
      transferToCluster: 1e12,
      adjustStake: 1e12,
      ...options
    };
    const abi = new import_api_contract.Abi(this.metadata);
    const callData = abi.findConstructor(constructor).toU8a(params);
    const result = await TxHandler.handle(this.api.tx.phalaFatContracts.instantiateContract({
      WasmCode: this.metadata.source.hash
    }, callData, "0x" + options.salt.toString(16), this.clusterId, options.transfer, options.gasLimit, options.storageDepositLimit, options.deposit), this._devPhase.accounts[options.asAccount], "phalaFatContracts.instantiateContract");
    const instantiateEvent = result.events.find(({ event }) => {
      return event.section === "phalaFatContracts" && event.method === "Instantiating";
    });
    if (!instantiateEvent) {
      throw "Error while instantiating contract";
    }
    const contractId = instantiateEvent.event.data[0].toString();
    let instantiated = false;
    let publicKey = null;
    this._eventQueue.registerHandler("phalaFatContracts.Instantiated", {
      0: contractId
    }, async (event) => {
      instantiated = true;
    });
    this._eventQueue.registerHandler("phalaFatContracts.ContractPubkeyAvailable", {
      0: contractId
    }, async (event) => {
      const eventData = event.data.toJSON();
      publicKey = eventData[2];
    });
    try {
      await this._waitFor(async () => {
        return instantiated && !!publicKey;
      }, 2e4, {
        message: "Contract instantiation"
      });
    } catch (e) {
      throw new Exception("Could not get contract public key", 1663952347291, e);
    }
    if (options.transferToCluster) {
      const result1 = await TxHandler.handle(this.api.tx.phalaFatContracts.transferToCluster(options.transferToCluster, this.clusterId, contractId), this._devPhase.accounts[options.asAccount], "phalaFatContracts.transferToCluster");
    }
    if (options.adjustStake) {
      const result2 = await TxHandler.handle(this.api.tx.phalaFatTokenomic.adjustStake(contractId, options.adjustStake), this._devPhase.accounts[options.asAccount], "phalaFatTokenomic.adjustStake");
    }
    return this.attach(contractId);
  }
  async attach(contractId) {
    const api = await this._devPhase.createApiPromise();
    const { api: workerApi } = await PhalaSdk.create({
      api,
      baseURL: this._devPhase.workerUrl,
      contractId,
      autoDeposit: true
    });
    const instance = new import_api_contract.ContractPromise(workerApi, this.metadata, contractId);
    Object.assign(instance, {
      contractId,
      clusterId: this.clusterId
    });
    return instance;
  }
  async _waitFor(callback, timeLimit, options = {}) {
    const firstTry = await callback();
    if (firstTry) {
      return firstTry;
    }
    if (options.message) {
      this._logger.debug("Waiting for", import_chalk3.default.cyan(options.message));
    }
    const result = waitFor(callback, timeLimit, options);
    this._logger.debug(import_chalk3.default.green("Ready"));
    return result;
  }
};
__name(ContractFactory, "ContractFactory");

// src/service/api/StackSetupService.ts
var import_axios = __toESM(require("axios"));
var import_chalk4 = __toESM(require("chalk"));
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var _StackSetupService = class {
  constructor(_devPhase) {
    this._devPhase = _devPhase;
    this._logger = new Logger(_StackSetupService.name);
    this._accounts = {};
    this._eventQueue = new EventQueue();
    this._context = this._devPhase.runtimeContext;
    this._accounts = this._devPhase.accounts;
    this._suAccount = this._devPhase.suAccount;
    this._blockTime = this._devPhase.runtimeContext.config.stack.blockTime;
    this._waitTime = Math.max(2e4, 4 * this._blockTime);
  }
  async setupStack(options) {
    this._api = this._devPhase.api;
    const setupStackVersion = _StackSetupService.MAP_STACK_TO_SETUP[this._context.config.stack.version] ?? "default";
    const setupStackMethod = "setupStack_" + setupStackVersion;
    if (!this[setupStackMethod]) {
      throw new Exception("Undefined setup environment procedure for this stack version", 1668661427343);
    }
    return this[setupStackMethod](options);
  }
  async setupStack_default(options) {
    await this.prepareWorker(options.workerUrl);
    await this.prepareGatekeeper();
    await this.preparePhatContractsSystem();
    if (options.clusterId === void 0) {
      const clustersNum = (await this._api.query.phalaFatContracts.clusterCounter()).toJSON();
      if (clustersNum == 0) {
        options.clusterId = null;
      } else {
        options.clusterId = "0x0000000000000000000000000000000000000000000000000000000000000000";
      }
    }
    const clusterId = options.clusterId === null ? await this.createCluster() : options.clusterId;
    await this.waitForClusterReady(options.clusterId);
    return {
      clusterId
    };
  }
  async prepareWorker(workerUrl) {
    const workerApi = import_axios.default.create({
      baseURL: workerUrl
    });
    this._workerInfo = await this._waitFor(async () => {
      const { status, data } = await workerApi.get("/get_info", {
        validateStatus: () => true
      });
      if (status === 200) {
        const payload = JSON.parse(data.payload);
        if (!payload.initialized) {
          return false;
        }
        return {
          publicKey: "0x" + payload.public_key,
          ecdhPublicKey: "0x" + payload.ecdh_public_key
        };
      }
      throw new Exception("Unable to get worker info", 1663941402827);
    }, this._waitTime, {
      message: "pRuntime initialization"
    });
    const workerInfo = (await this._api.query.phalaRegistry.workers(this._workerInfo.ecdhPublicKey)).toJSON();
    if (!workerInfo) {
      const tx = this._api.tx.sudo.sudo(this._api.tx.phalaRegistry.forceRegisterWorker(this._workerInfo.publicKey, this._workerInfo.ecdhPublicKey, null));
      const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaRegistry.forceRegisterWorker)");
      await this._waitFor(async () => {
        return (await this._api.query.phalaRegistry.workers(this._workerInfo.ecdhPublicKey)).toJSON();
      }, this._waitTime, {
        message: "Worker registration"
      });
    }
  }
  async prepareGatekeeper() {
    const gatekeepers = (await this._api.query.phalaRegistry.gatekeeper()).toJSON();
    if (!gatekeepers.includes(this._workerInfo.publicKey)) {
      const tx = this._api.tx.sudo.sudo(this._api.tx.phalaRegistry.registerGatekeeper(this._workerInfo.publicKey));
      const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaRegistry.registerGatekeeper)");
    }
    try {
      await this._waitFor(async () => {
        return !(await this._api.query.phalaRegistry.gatekeeperMasterPubkey()).isEmpty;
      }, this._waitTime, {
        message: "GK master key generation"
      });
    } catch (e) {
      throw new Exception("Could not fetch GK master key", 1663941402827);
    }
  }
  async preparePhatContractsSystem() {
    if (!this._context) {
      throw new Exception("Non available out of runtime context environment", 1668658002543);
    }
    const systemContractPath = import_path.default.join(this._context.paths.currentStack, "system.contract");
    if (!import_fs.default.existsSync(systemContractPath)) {
      throw new Exception("Phat contracts system not found in stacks", 1668748436052);
    }
    const systemContract = JSON.parse(import_fs.default.readFileSync(systemContractPath, {
      encoding: "utf-8"
    }));
    const systemCode = systemContract.source.wasm;
    const pinkSystemCode = await this._api.query.phalaFatContracts.pinkSystemCode();
    const isPinkSystemCodeReady = pinkSystemCode[1].toString() === systemCode;
    if (isPinkSystemCodeReady) {
      return;
    }
    this._logger.log("Preparing Phat Contracts system");
    const tx = this._api.tx.sudo.sudo(this._api.tx.phalaFatContracts.setPinkSystemCode(systemCode));
    const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaFatContracts.setPinkSystemCode)");
    await this._waitFor(async () => {
      const code = await this._api.query.phalaFatContracts.pinkSystemCode();
      return code[1].toString() === systemCode;
    }, this._waitTime, {
      message: "PinkSystemCode setup"
    });
  }
  async createCluster() {
    this._logger.log("Creating cluster");
    const tx = this._api.tx.sudo.sudo(this._api.tx.phalaFatContracts.addCluster(
      this._accounts.alice.address,
      {
        Public: null
      },
      [
        this._workerInfo.publicKey
      ],
      1e12,
      1,
      1,
      1,
      this._accounts.alice.address
    ));
    const result = await TxHandler.handle(tx, this._suAccount, "sudo(phalaFatContracts.addCluster)");
    const clusterCreatedEvent = result.events.find(({ event }) => {
      return event.section === "phalaFatContracts" && event.method === "ClusterCreated";
    });
    if (!clusterCreatedEvent) {
      throw new Exception("Error while creating cluster", 1663941940784);
    }
    const clusterId = clusterCreatedEvent.event.data[0].toString();
    this._logger.log(import_chalk4.default.green("Cluster created"));
    this._logger.log(clusterId);
    return clusterId;
  }
  async waitForClusterReady(clusterId) {
    return this._waitFor(async () => {
      const cluster = await this._api.query.phalaFatContracts.clusters(clusterId);
      if (cluster.isEmpty) {
        return false;
      }
      const clusterKey = await this._api.query.phalaRegistry.clusterKeys(clusterId);
      if (clusterKey.isEmpty) {
        return false;
      }
      return true;
    }, this._waitTime, {
      message: "Cluster ready"
    });
  }
  async _waitFor(callback, timeLimit, options = {}) {
    const firstTry = await callback();
    if (firstTry) {
      return firstTry;
    }
    if (options.message) {
      this._logger.debug("Waiting for", import_chalk4.default.cyan(options.message));
    }
    const result = waitFor(callback, timeLimit, options);
    this._logger.debug(import_chalk4.default.green("Ready"));
    return result;
  }
};
var StackSetupService = _StackSetupService;
__name(StackSetupService, "StackSetupService");
__publicField(StackSetupService, "MAP_STACK_TO_SETUP", {});

// src/service/project/AccountManager.ts
var Keyring = __toESM(require("@polkadot/keyring"));
var import_util_crypto = require("@polkadot/util-crypto");
var import_wasm_crypto = require("@polkadot/wasm-crypto");
var import_chalk5 = __toESM(require("chalk"));
var import_fs2 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var import_prompts = __toESM(require("prompts"));
var AccountManager = class {
  constructor(_runtimeContext) {
    this._runtimeContext = _runtimeContext;
    this._logger = new Logger(AccountManager.name);
  }
  async loadAccountsKeyringsFromStorageFile() {
    const accountsStoragePath = import_path2.default.join(this._runtimeContext.paths.project, "accounts.json");
    if (!import_fs2.default.existsSync(accountsStoragePath)) {
      return null;
    }
    return JSON.parse(import_fs2.default.readFileSync(accountsStoragePath, {
      encoding: "utf-8"
    }));
  }
  async loadAccounts(accountKeyrings, ss58Format = 30, unlock = true) {
    await (0, import_wasm_crypto.waitReady)();
    const accounts = {};
    const keyring = new Keyring.Keyring();
    if (ss58Format) {
      keyring.setSS58Format(ss58Format);
    }
    for (const [alias, accountKeyring] of Object.entries(accountKeyrings)) {
      if (typeof accountKeyring === "string") {
        accounts[alias] = keyring.createFromUri(accountKeyring, void 0, "sr25519");
      } else {
        accounts[alias] = keyring.createFromJson(accountKeyring);
      }
    }
    if (unlock) {
      for (const [alias1, keyring1] of Object.entries(accounts)) {
        if (keyring1.isLocked) {
          const { password } = await (0, import_prompts.default)({
            type: "password",
            name: "password",
            message: `Account ${import_chalk5.default.cyan(alias1)} is locked. Provide password:`
          });
          try {
            keyring1.unlock(password);
          } catch (e) {
            throw new Exception("Unable to unlock account keyring", 1673268293515, e);
          }
        }
      }
    }
    return accounts;
  }
  async createAccount(ss58Format = 30) {
    const account = {
      alias: "",
      keyring: null
    };
    const { alias } = await (0, import_prompts.default)({
      type: "text",
      name: "alias",
      message: `Account alias`,
      validate: (alias2) => /^[a-z0-9_]+$/.test(alias2)
    });
    account.alias = alias;
    const keyring = new Keyring.Keyring({
      type: "sr25519",
      ss58Format
    });
    const mnemonic = (0, import_util_crypto.mnemonicGenerate)();
    account.keyring = keyring.addFromMnemonic(mnemonic);
    const { password } = await (0, import_prompts.default)({
      type: "password",
      name: "password",
      message: `Account password (leave empty if to save as plain text)`
    });
    const exported = !!password ? account.keyring.toJson(password) : mnemonic;
    const accountsConfigPath = import_path2.default.join(this._runtimeContext.paths.project, "accounts.json");
    if (!import_fs2.default.existsSync(accountsConfigPath)) {
      return null;
    }
    const accountsJson = JSON.parse(import_fs2.default.readFileSync(accountsConfigPath, {
      encoding: "utf-8"
    }));
    accountsJson[alias] = exported;
    import_fs2.default.writeFileSync(accountsConfigPath, JSON.stringify(accountsJson, void 0, 4), {
      encoding: "utf-8"
    });
    return account;
  }
};
__name(AccountManager, "AccountManager");

// src/utils/replaceRecursive.ts
var import_mergeWith = __toESM(require("lodash/mergeWith"));
function replaceRecursive(target, ...source) {
  return (0, import_mergeWith.default)(target, ...source, (obj, src) => {
    if (src instanceof Array) {
      return src;
    }
  });
}
__name(replaceRecursive, "replaceRecursive");

// src/service/api/DevPhase.ts
var import_api = require("@polkadot/api");
var import_fs3 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
var DevPhase = class {
  accounts = {};
  mainClusterId = "0x0000000000000000000000000000000000000000000000000000000000000000";
  _logger = new Logger(DevPhase.name);
  _eventQueue = new EventQueue();
  constructor() {
  }
  static async create(runtimeContext, network) {
    const instance = new DevPhase();
    const networkConfig = runtimeContext.config.networks[network];
    if (!networkConfig) {
      throw new Exception("Undefined network", 1673537590278);
    }
    instance._apiOptions = networkConfig.nodeApiOptions;
    instance._apiProvider = new import_api.WsProvider(networkConfig.nodeUrl);
    const api = await instance.createApiPromise();
    await instance._eventQueue.init(api);
    Object.assign(instance, {
      network,
      networkConfig,
      runtimeContext,
      api,
      workerUrl: networkConfig.workerUrl
    });
    const accountManager = new AccountManager(runtimeContext);
    const accountsConfig = replaceRecursive({}, runtimeContext.config.accountsConfig);
    const accountsKeyrings = await accountManager.loadAccountsKeyringsFromStorageFile();
    if (accountsKeyrings) {
      replaceRecursive(accountsConfig, accountsKeyrings);
    }
    const accounts = await accountManager.loadAccounts(accountsConfig.keyrings, runtimeContext.config.general.ss58Format, true);
    Object.assign(instance, {
      accounts,
      suAccount: accounts[accountsConfig.suAccount]
    });
    return instance;
  }
  async createApiPromise() {
    return import_api.ApiPromise.create({
      provider: this._apiProvider,
      ...this._apiOptions
    });
  }
  async stackSetup() {
    if (!this.runtimeContext) {
      throw new Exception("Stack setup is not possible out of runtime context", 1668741635272);
    }
    const stackSetupService = new StackSetupService(this);
    const result = await stackSetupService.setupStack(this.runtimeContext.config.stack.setupOptions);
    Object.assign(this, {
      mainClusterId: result.clusterId
    });
  }
  async cleanup() {
    await this._eventQueue.destroy();
    await this.api.disconnect();
  }
  async getFactory(type, artifactPathOrName, options = {}) {
    options = {
      clusterId: this.mainClusterId,
      ...options
    };
    const isContractName = /^[a-z0-9_]+$/i.test(artifactPathOrName);
    let artifactPath = artifactPathOrName;
    if (isContractName) {
      artifactPath = import_path3.default.join(this.runtimeContext.paths.artifacts, artifactPathOrName, `${artifactPathOrName}.contract`);
    }
    if (!import_fs3.default.existsSync(artifactPath)) {
      throw new Exception("Contract artifact file not found", 1665238985042);
    }
    const contractRaw = import_fs3.default.readFileSync(artifactPath, {
      encoding: "utf-8"
    });
    try {
      const metadata = JSON.parse(contractRaw);
      return ContractFactory.create(this, type, metadata, options.clusterId);
    } catch (e) {
      throw new Exception("Failed to parse contract artifiact JSON", 1665238941553, e);
    }
  }
};
__name(DevPhase, "DevPhase");

// src/service/project/StackBinaryDownloader.ts
var import_axios2 = __toESM(require("axios"));
var import_chalk6 = __toESM(require("chalk"));
var import_fs4 = __toESM(require("fs"));
var import_path4 = __toESM(require("path"));
var _StackBinaryDownloader = class {
  constructor(_context) {
    this._context = _context;
    this._logger = new Logger(_StackBinaryDownloader.name);
  }
  async uniformStackVersion(version) {
    if (version === "latest") {
      const releases = await this.getReleases();
      return releases[0].tag_name;
    }
    return version;
  }
  async getReleases() {
    const cachePath = import_path4.default.join(this._context.paths.context, "releases.json");
    if (import_fs4.default.existsSync(cachePath)) {
      const stat = import_fs4.default.statSync(cachePath);
      const outdated = Date.now() - stat.ctimeMs > _StackBinaryDownloader.RELEASES_CACHE_TIME;
      if (!outdated) {
        const releasesCacheRaw = import_fs4.default.readFileSync(cachePath, {
          encoding: "utf-8"
        });
        this._releases = JSON.parse(releasesCacheRaw);
      }
    }
    if (this._releases) {
      return this._releases;
    }
    const { status, data } = await import_axios2.default.get(_StackBinaryDownloader.RELEASES_URL, {
      validateStatus: () => true
    });
    if (status !== 200) {
      throw new Exception("Unable to fetch releases list", 1668571559267);
    }
    const releasesCacheRaw1 = JSON.stringify(data);
    import_fs4.default.writeFileSync(cachePath, releasesCacheRaw1, {
      encoding: "utf-8"
    });
    return data;
  }
  async findRelease(tagName) {
    const releases = await this.getReleases();
    const targetRelease = releases.find((release) => release.tag_name === tagName);
    if (!targetRelease) {
      throw new Exception(`Unable to find target ${tagName} release`, 1668572613089);
    }
    return targetRelease;
  }
  async downloadIfRequired() {
    const releaseStackPath = this._context.paths.currentStack;
    if (!import_fs4.default.existsSync(releaseStackPath)) {
      this._logger.log("Creating stack directory");
      import_fs4.default.mkdirSync(releaseStackPath, {
        recursive: true
      });
    }
    let needsDownload = !import_fs4.default.existsSync(this._context.config.stack.node.binary);
    if (!needsDownload) {
      return;
    }
    const release = await this.findRelease(this._context.config.stack.version);
    this._logger.log("Downloading stack binaries", import_chalk6.default.cyan(release.name));
    for (const asset of release.assets) {
      const isBinary = _StackBinaryDownloader.EXECUTABLES.includes(asset.name);
      const filePath = import_path4.default.join(releaseStackPath, asset.name);
      if (import_fs4.default.existsSync(filePath)) {
        continue;
      }
      this._logger.log(isBinary ? import_chalk6.default.greenBright(asset.name) : import_chalk6.default.blueBright(asset.name));
      const { status, data } = await import_axios2.default.get(asset.browser_download_url, {
        responseType: "arraybuffer",
        headers: {
          "Content-Type": "application/gzip"
        },
        validateStatus: () => true
      });
      if (status !== 200) {
        throw new Exception("Unable to download release", 1668572702020);
      }
      import_fs4.default.writeFileSync(filePath, data, {
        encoding: "binary"
      });
      if (isBinary) {
        import_fs4.default.chmodSync(filePath, 493);
      }
    }
  }
};
var StackBinaryDownloader = _StackBinaryDownloader;
__name(StackBinaryDownloader, "StackBinaryDownloader");
__publicField(StackBinaryDownloader, "RELEASES_URL", "https://api.github.com/repos/Phala-Network/phala-blockchain/releases");
__publicField(StackBinaryDownloader, "RELEASES_CACHE_TIME", 60 * 60 * 1e3);
__publicField(StackBinaryDownloader, "EXECUTABLES", [
  "phala-node",
  "pruntime",
  "pherry"
]);

// src/utils/accessThroughPath.ts
function accessThroughPath(obj, path7, options = {}) {
  options = {
    throwOnFailure: true,
    autoCreate: false,
    ...options
  };
  const parts = path7.split(".");
  const currentPath = [];
  let part = null;
  while (part = parts.shift()) {
    currentPath.push(part);
    const isLeaf = !parts.length;
    if (obj[part] === void 0) {
      if (isLeaf) {
        return void 0;
      } else if (options.autoCreate) {
        obj[part] = {};
      } else if (options.throwOnFailure) {
        const fullPath = currentPath.join(".");
        throw new Exception(`Undefined node at ${fullPath}`, 1641922707436);
      } else {
        return void 0;
      }
    }
    obj = obj[part];
  }
  return obj;
}
__name(accessThroughPath, "accessThroughPath");

// src/utils/replacePlaceholders.ts
function replacePlaceholders(node, root, options = {}) {
  options = {
    placeholderRegex: /\{\{(.*?)\}\}/g,
    ...options
  };
  for (const [prop, value] of Object.entries(node)) {
    if (typeof value === "string") {
      node[prop] = value.replaceAll(options.placeholderRegex, (match, path7) => {
        return accessThroughPath(root, path7);
      });
    } else if (value instanceof Object) {
      replacePlaceholders(value, root, options);
    }
  }
}
__name(replacePlaceholders, "replacePlaceholders");

// src/service/project/RuntimeContext.ts
var import_sdk = require("@phala/sdk");
var import_typedefs = require("@phala/typedefs");
var import_find_up = __toESM(require("find-up"));
var import_fs5 = __toESM(require("fs"));
var import_path5 = __toESM(require("path"));
var _RuntimeContext = class {
  _devPhases = {};
  paths = {
    devphase: null,
    templates: null,
    project: null,
    context: null,
    artifacts: null,
    contracts: null,
    logs: null,
    currentLog: null,
    scripts: null,
    stacks: null,
    currentStack: null,
    tests: null,
    typings: null
  };
  static async getSingleton() {
    const globalAny = global;
    const singletonKey = _RuntimeContext.SINGLETON_KEY;
    if (!globalAny[singletonKey]) {
      const instance = new _RuntimeContext();
      globalAny[singletonKey] = instance;
    }
    return globalAny[singletonKey];
  }
  constructor() {
    this._stackBinaryDownloader = new StackBinaryDownloader(this);
  }
  async isInProjectDirectory() {
    const configFilePath = await (0, import_find_up.default)([
      "devphase.config.ts",
      "devphase.config.js"
    ]);
    return configFilePath !== void 0;
  }
  async requestProjectDirectory() {
    const isInProjectDirectory = await this.isInProjectDirectory();
    if (!isInProjectDirectory) {
      throw new Exception("Config file not found", 1665952724703);
    }
  }
  async initContext(runMode, network = _RuntimeContext.NETWORK_LOCAL) {
    const configFilePath = await (0, import_find_up.default)([
      "devphase.config.ts",
      "devphase.config.js"
    ]);
    this.paths.devphase = __dirname.endsWith("/cli") ? import_path5.default.join(__dirname, "../../") : import_path5.default.join(__dirname, "../");
    this.paths.templates = import_path5.default.join(this.paths.devphase, "templates");
    let userConfig = {};
    if (configFilePath) {
      this.paths.project = import_path5.default.dirname(configFilePath);
      userConfig = require(configFilePath).default;
    } else {
      this.paths.project = process.cwd();
    }
    this.paths.context = import_path5.default.join(this.paths.project, ".devphase");
    if (!import_fs5.default.existsSync(this.paths.context)) {
      import_fs5.default.mkdirSync(this.paths.context, {
        recursive: true
      });
    }
    const config = await this._getRunConfiguration(userConfig, runMode);
    Object.assign(this, {
      config
    });
    for (const [name, directory] of Object.entries(this.config.directories)) {
      this.paths[name] = import_path5.default.resolve(this.paths.project, directory);
    }
    const logStamp = new Date().toISOString();
    this.paths.currentLog = import_path5.default.join(this.paths.logs, logStamp);
    this.paths.currentStack = import_path5.default.join(this.paths.stacks, this.config.stack.version);
    if (runMode === RunMode.Testing) {
      this.config.networks.local.blockTime = this.config.testing.blockTime;
    }
  }
  async initDevPhase(network = _RuntimeContext.NETWORK_LOCAL) {
    if (this._devPhases[network]) {
      throw new Exception("DevPhase was already initiated", 1673451278525);
    }
    this._devPhases[network] = await DevPhase.create(this, network);
    return this._devPhases[network];
  }
  getDevPhase(network = _RuntimeContext.NETWORK_LOCAL) {
    if (!this._devPhases[network]) {
      throw new Exception("DevPhase is not ready yet", 1673451408519);
    }
    return this._devPhases[network];
  }
  async requestStackBinaries() {
    await this._stackBinaryDownloader.downloadIfRequired();
  }
  async _getRunConfiguration(options, runMode) {
    const config = replaceRecursive({
      general: {
        ss58Format: 30
      },
      directories: {
        artifacts: "artifacts",
        contracts: "contracts",
        logs: "logs",
        stacks: "stacks",
        tests: "tests",
        typings: "typings"
      },
      stack: {
        blockTime: 6e3,
        version: "latest",
        setupOptions: {
          workerUrl: "http://localhost:{{stack.pruntime.port}}",
          clusterId: void 0
        },
        node: {
          port: 9944,
          binary: "{{directories.stacks}}/{{stack.version}}/phala-node",
          workingDir: "{{directories.stacks}}/.data/node",
          envs: {},
          args: {
            "--dev": true,
            "--rpc-methods": "Unsafe",
            "--block-millisecs": "{{stack.blockTime}}",
            "--ws-port": "{{stack.node.port}}",
            "--base-path": "."
          },
          timeout: 1e4
        },
        pruntime: {
          port: 8e3,
          binary: "{{directories.stacks}}/{{stack.version}}/pruntime",
          workingDir: "{{directories.stacks}}/.data/pruntime",
          envs: {},
          args: {
            "--allow-cors": true,
            "--cores": 0,
            "--port": "{{stack.pruntime.port}}"
          },
          timeout: 2e3
        },
        pherry: {
          gkMnemonic: "//Alice",
          binary: "{{directories.stacks}}/{{stack.version}}/pherry",
          workingDir: "{{directories.stacks}}/.data/pherry",
          envs: {},
          args: {
            "--no-wait": true,
            "--mnemonic": "{{stack.pherry.gkMnemonic}}",
            "--inject-key": "0000000000000000000000000000000000000000000000000000000000000001",
            "--substrate-ws-endpoint": "ws://localhost:{{stack.node.port}}",
            "--pruntime-endpoint": "http://localhost:{{stack.pruntime.port}}",
            "--dev-wait-block-ms": "{{stack.blockTime}}",
            "--attestation-provider": "none"
          },
          timeout: 5e3
        }
      },
      testing: {
        mocha: {},
        spawnStack: true,
        stackLogOutput: false,
        blockTime: 100,
        envSetup: {
          setup: {
            custom: void 0,
            timeout: 60 * 1e3
          },
          teardown: {
            custom: void 0,
            timeout: 10 * 1e3
          }
        }
      },
      networks: {
        local: {
          nodeUrl: "ws://localhost:{{stack.node.port}}",
          nodeApiOptions: {
            types: {
              ...import_typedefs.khalaDev,
              ...import_sdk.types
            }
          },
          workerUrl: "http://localhost:{{stack.pruntime.port}}",
          blockTime: 6e3
        }
      },
      accountsConfig: {
        keyrings: {
          alice: "//Alice",
          bob: "//Bob",
          charlie: "//Charlie",
          dave: "//Dave",
          eve: "//Eve",
          ferdie: "//Ferdie"
        },
        suAccount: "alice"
      }
    }, options);
    config.stack.version = await this._stackBinaryDownloader.uniformStackVersion(config.stack.version);
    if (runMode === RunMode.Testing) {
      config.stack.blockTime = config.testing.blockTime;
    }
    replacePlaceholders(config, config);
    return config;
  }
};
var RuntimeContext = _RuntimeContext;
__name(RuntimeContext, "RuntimeContext");
__publicField(RuntimeContext, "SINGLETON_KEY", "devphase_Context_VSffVql3bvj9aulZY5DNnRCnrEt1V27a");
__publicField(RuntimeContext, "NETWORK_LOCAL", "local");

// src/utils/serializeProcessArgs.ts
function serializeProcessArgs(args) {
  const serialized = [];
  for (const [name, value] of Object.entries(args)) {
    if ([
      void 0,
      null,
      false
    ].includes(value)) {
      continue;
    } else if (value === true) {
      serialized.push(name);
    } else {
      serialized.push(name + "=" + value);
    }
  }
  return serialized;
}
__name(serializeProcessArgs, "serializeProcessArgs");

// src/utils/timeout.ts
function timeout(callback, timeLimit, options = {}) {
  options = {
    message: "Timeout",
    ...options
  };
  return new Promise(async (resolve, reject) => {
    const _timeout = setTimeout(() => reject(new Exception(options.message, 1663946429155)), timeLimit);
    try {
      const result = await callback();
      clearTimeout(_timeout);
      resolve(result);
    } catch (e) {
      clearTimeout(_timeout);
      reject(e);
    }
  });
}
__name(timeout, "timeout");

// src/service/project/StackManager.ts
var import_chalk7 = __toESM(require("chalk"));
var import_child_process = __toESM(require("child_process"));
var import_fs6 = __toESM(require("fs"));
var import_cloneDeep = __toESM(require("lodash/cloneDeep"));
var import_path6 = __toESM(require("path"));
var StackManager = class {
  constructor(_context) {
    this._context = _context;
    this._logger = new Logger(StackManager.name);
    this._killFlag = false;
    this._runLogsPath = this._context.paths.currentLog;
  }
  async startStack(runMode) {
    if (this._processes) {
      throw new Exception("Stack processes already started", 1666229698364);
    }
    if (this.isLogOutputUsed(runMode, this._context)) {
      import_fs6.default.mkdirSync(this._runLogsPath, {
        recursive: true
      });
    }
    this._processes = {
      node: null,
      pruntime: null,
      pherry: null
    };
    this._processes.node = await this.startNode(runMode);
    if (this._killFlag) {
      return this._processes;
    }
    this._processes.pruntime = await this.startPruntime(runMode);
    if (this._killFlag) {
      return this._processes;
    }
    this._processes.pherry = await this.startPherry(runMode);
    return this._processes;
  }
  async stopStack(force = false) {
    var _a, _b, _c, _d, _e, _f;
    this._killFlag = true;
    if (!this._processes) {
      throw new Exception("Stack was not started yet", 1666229971488);
    }
    const signal = force ? "SIGKILL" : "SIGTERM";
    if (!((_a = this._processes.pherry) == null ? void 0 : _a.killed)) {
      (_b = this._processes.pherry) == null ? void 0 : _b.kill(signal);
    }
    if (!((_c = this._processes.pruntime) == null ? void 0 : _c.killed)) {
      (_d = this._processes.pruntime) == null ? void 0 : _d.kill(signal);
    }
    if (!((_e = this._processes.node) == null ? void 0 : _e.killed)) {
      (_f = this._processes.node) == null ? void 0 : _f.kill(signal);
    }
  }
  async startNode(runMode) {
    const options = (0, import_cloneDeep.default)(this._context.config.stack.node);
    return this.startComponent("node", options, runMode, (text) => text.includes("Running JSON-RPC"), (text) => text.toLowerCase().includes("error"));
  }
  async startPruntime(runMode) {
    const options = (0, import_cloneDeep.default)(this._context.config.stack.pruntime);
    return this.startComponent("pruntime", options, runMode, (text) => text.includes("Rocket has launched from"), (text) => text.toLowerCase().includes("error"));
  }
  async startPherry(runMode) {
    const options = (0, import_cloneDeep.default)(this._context.config.stack.pherry);
    return this.startComponent("pherry", options, runMode, (text) => text.includes("pRuntime get_info response: PhactoryInfo"), (text) => text.toLowerCase().includes("error"));
  }
  async startComponent(componentName, options, runMode, waitForReady = () => true, waitForError = () => false) {
    const binaryPath = this.getComponentPath(options.binary);
    const workingDirPath = this.getComponentPath(options.workingDir);
    if (import_fs6.default.existsSync(workingDirPath)) {
      import_fs6.default.rmSync(workingDirPath, {
        recursive: true,
        force: true
      });
    }
    import_fs6.default.mkdirSync(workingDirPath, {
      recursive: true
    });
    const spawnOptions = {
      cwd: workingDirPath,
      env: {
        ...process.env,
        ...options.envs
      },
      stdio: [
        "ignore",
        "pipe",
        "pipe"
      ]
    };
    const binaryName = import_path6.default.basename(binaryPath);
    this._logger.log("Waiting for", import_chalk7.default.cyan(binaryName), "to start with", (options.timeout / 1e3).toFixed(1), "s timeout.");
    const child = import_child_process.default.spawn(binaryPath, serializeProcessArgs(options.args), spawnOptions);
    const [stdin, stdout, stderr] = child.stdio;
    stdout.setEncoding("utf-8");
    stderr.setEncoding("utf-8");
    let logFileDscr;
    if (this.isLogOutputUsed(runMode, this._context)) {
      const logFilePath = import_path6.default.join(this._runLogsPath, `${componentName}.log`);
      logFileDscr = import_fs6.default.openSync(logFilePath, "a");
      child.on("close", () => {
        import_fs6.default.closeSync(logFileDscr);
      });
    }
    let settled = false;
    await timeout(() => {
      return new Promise((resolve, reject) => {
        const interval = setInterval(() => {
          if (this._killFlag) {
            child.kill("SIGKILL");
            cleanup();
            reject(new Exception("Component killed", 1667576698031));
          }
        }, 250);
        const cleanup = /* @__PURE__ */ __name(() => {
          settled = true;
          clearInterval(interval);
        }, "cleanup");
        const watchFn = /* @__PURE__ */ __name((chunk) => {
          const text = chunk.toString();
          if (runMode === RunMode.Simple) {
            console.log(import_chalk7.default.blueBright(`[${binaryName}]`));
            process.stdout.write(text);
          } else if (this.isLogOutputUsed(runMode, this._context)) {
            import_fs6.default.appendFileSync(logFileDscr, text, {
              encoding: "utf-8"
            });
          }
          if (!settled) {
            if (waitForReady(text)) {
              this._logger.log("Binary", import_chalk7.default.cyan(binaryName), "started");
              cleanup();
              resolve(child);
            } else if (waitForError(text)) {
              cleanup();
              reject(new Exception(`Failed to start ${binaryName} component`, 1666286544430));
            }
          }
        }, "watchFn");
        stdout.on("data", watchFn);
        stderr.on("data", watchFn);
      });
    }, options.timeout);
    return child;
  }
  getComponentPath(_path) {
    return import_path6.default.resolve(this._context.paths.project, _path);
  }
  isLogOutputUsed(runMode, context) {
    return runMode === RunMode.Testing && context.config.testing.stackLogOutput;
  }
};
__name(StackManager, "StackManager");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ContractFactory,
  ContractType,
  DevPhase,
  Logger,
  LoggerLevel,
  RunMode,
  RuntimeContext,
  StackManager,
  TxHandler
});
